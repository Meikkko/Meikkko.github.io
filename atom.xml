<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-18T01:29:37.787Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>控制反转（IoC）和依赖注入（DI）的区别</title>
    <link href="http://yoursite.com/2019/08/18/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/18/控制反转（IoC）和依赖注入（DI）的区别/</id>
    <published>2019-08-18T01:22:42.000Z</published>
    <updated>2019-08-18T01:29:37.787Z</updated>
    
    <content type="html"><![CDATA[<p>IOC   inversion of control  控制反转</p><p>DI   Dependency Injection  依赖注入</p><p>要理解这两个概念，首先要搞清楚以下几个问题：</p><p>参与者都有谁？<br>依赖：谁依赖于谁？为什么需要依赖？<br>注入：谁注入于谁？到底注入什么？<br>控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了）？<br>依赖注入和控制反转是同一概念吗？<br>        下面就来简要的回答一下上述问题，把这些问题搞明白了，IoC/DI也就明白了。<br>（1）参与者都有谁：</p><pre><code>一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。又要名词解释一下，某个对象指的就是任意的、普通的Java对象; IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。</code></pre><p>（2）谁依赖于谁：</p><pre><code>当然是某个对象依赖于IoC/DI的容器</code></pre><p>（3）为什么需要依赖：</p><pre><code>对象需要IoC/DI的容器来提供对象需要的外部资源</code></pre><p>（4）谁注入于谁：</p><pre><code>很明显是IoC/DI的容器 注入 某个对象</code></pre><p>（5）到底注入什么：</p><pre><code>就是注入某个对象所需要的外部资源</code></pre><p>（6）谁控制谁：</p><pre><code>当然是IoC/DI的容器来控制对象了</code></pre><p>（7）控制什么：</p><pre><code>主要是控制对象实例的创建</code></pre><p>（8）为何叫反转：</p><pre><code>反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。</code></pre><p>用图例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如图7所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265411/6fe19539-32ce-3a62-bc20-f8dc1e819f82.gif" alt><br>                                      常规A使用C示意图</p><p>当有了IoC/DI的容器后，A类不再主动去创建C了，如图8所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265413/e29bb428-b9f0-3465-8601-671c3fa68b8c.gif" alt><br>                                      A类不再主动创建C</p><p>而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中，如图9所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265415/2a537021-45c9-3fd3-80c5-18b9ace2b27a.gif" alt><br>                                      有IoC/DI容器后程序结构示意图</p><p>（9）依赖注入和控制反转是同一概念吗？</p><pre><code>根据上面的讲述，应该能看出来，依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</code></pre><p>（10）小结一下：</p><pre><code>其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。这么小小的一个改变其实是编程思想的一个大进步，这样就有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</code></pre><p>（11）接下演示一下依赖注入机制的过程</p><p>代码2<br>待注入的业务对象Content.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBusniess类展示了一个业务组件，它的实现需要对象Content的注入。代码3，代码4，代码5，6分别演示构造子注入（Constructor Injection），设值注入（Setter Injection）和接口注入（Interface Injection）三种方式。</p><p>代码3<br>构造子注入（Constructor Injection）MyBusiness.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码4<br>设值注入（Setter Injection） MyBusiness.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码5<br>   设置注入接口InContent.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>代码6接口注入（Interface Injection）MyBusiness.java</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness implements InContent&#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public void createContent(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusniess()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusniess()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IOC   inversion of control  控制反转&lt;/p&gt;
&lt;p&gt;DI   Dependency Injection  依赖注入&lt;/p&gt;
&lt;p&gt;要理解这两个概念，首先要搞清楚以下几个问题：&lt;/p&gt;
&lt;p&gt;参与者都有谁？&lt;br&gt;依赖：谁依赖于谁？为什么需要依赖？
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="http://yoursite.com/2019/07/28/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/07/28/测试图片/</id>
    <published>2019-07-28T08:42:01.000Z</published>
    <updated>2019-07-28T08:42:41.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/18958678-866bf1d1b152cea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/18958678-866bf1d1b152cea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode第3号问题：无重复字符的最长子串</title>
    <link href="http://yoursite.com/2019/07/28/LeetCode%E7%AC%AC3%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/07/28/LeetCode第3号问题：无重复字符的最长子串/</id>
    <published>2019-07-28T07:57:48.000Z</published>
    <updated>2019-07-30T14:48:44.937Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>建立一个256位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/o2acw.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><figcaption><span>1,暴力法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="comment">// 时间复杂度: O(len(s))</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(len(charset))</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> longgest =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt;=s.length() ; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isUnique(s,i,j))&#123;</span><br><span class="line">                        longgest = Math.max(longgest, j-i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> longgest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end ; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 1 号问题：两数之和</title>
    <link href="http://yoursite.com/2019/07/27/LeetCode%E7%AC%AC1%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/07/27/LeetCode第1号问题：两数之和/</id>
    <published>2019-07-27T07:57:48.000Z</published>
    <updated>2019-07-28T08:12:16.823Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用查找表来解决该问题。</p><p>设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums。</p><ul><li>每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值</li><li>在此次遍历中查找 record ，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值 i</li><li>如果未找到，则在 record 保存该元素与索引值 i</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181028221055.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. Two Sum</span><br><span class="line">// https://leetcode.com/problems/two-sum/description/</span><br><span class="line">// 时间复杂度：O(n)</span><br><span class="line">// 空间复杂度：O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; record;</span><br><span class="line">        for(int i = 0 ; i &lt; nums.size() ; i ++)&#123;</span><br><span class="line">       </span><br><span class="line">            int complement = target - nums[i];</span><br><span class="line">            if(record.find(complement) != record.end())&#123;</span><br><span class="line">                int res[] = &#123;i, record[complement]&#125;;</span><br><span class="line">                return vector&lt;int&gt;(res, res + 2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 2 号问题：两数相加</title>
    <link href="http://yoursite.com/2019/07/23/LeetCode%E7%AC%AC2%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/07/23/LeetCode第2号问题：两数相加/</id>
    <published>2019-07-23T08:58:14.174Z</published>
    <updated>2019-07-28T08:47:42.092Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 2 号问题：两数相加。题目难度为 Medium，目前通过率为 33.9% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181117122234.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/// 时间复杂度: O(n)</span><br><span class="line">/// 空间复杂度: O(n)</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode *dummyHead = new ListNode(-1);</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        int carried = 0;</span><br><span class="line">        while(p1 || p2 )&#123;</span><br><span class="line">            int a = p1 ? p1-&gt;val : 0;</span><br><span class="line">            int b = p2 ? p2-&gt;val : 0;</span><br><span class="line">            cur-&gt;next = new ListNode((a + b + carried) % 10);</span><br><span class="line">            carried = (a + b + carried) / 10;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            p1 = p1 ? p1-&gt;next : NULL;</span><br><span class="line">            p2 = p2 ? p2-&gt;next : NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur-&gt;next = carried ? new ListNode(1) : NULL;</span><br><span class="line">        ListNode* ret = dummyHead-&gt;next;</span><br><span class="line">        delete dummyHead;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 2 号问题：两数相加。题目难度为 Medium，目前通过率为 33.9% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
