<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-31T09:46:52.969Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tips5 基础</title>
    <link href="http://yoursite.com/2019/10/31/Tips5-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/31/Tips5-基础/</id>
    <published>2019-10-31T09:45:45.000Z</published>
    <updated>2019-10-31T09:46:52.969Z</updated>
    
    <content type="html"><![CDATA[<p>41、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？<br>   hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><p>42、字节流与字符流的区别</p><p>   要把一段二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p><p>   计算机中的一切最终都是二进制的字节形式存在。对于经常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，Java专门提供了字符流包装类。</p><p>   底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p><p>   字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p><p>43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</p><pre><code>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输。但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是为了标注该对象是可被序列化的。例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现Serializable接口。</code></pre><p>44、描述一下JVM加载class文件的原理机制?</p><pre><code>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</code></pre><p>45、heap和stack有什么区别。</p><pre><code>java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。堆是与栈作用不同的内存，一般用于存放不在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。</code></pre><p>46、GC是什么?为什么要有GC?</p><pre><code>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</code></pre><p>47、垃圾回收的优点和原理。并考虑2种回收机制。</p><pre><code>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于垃圾回收机制，Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot;。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</code></pre><p>48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</p><pre><code>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</code></pre><p>49、Java 中，throw 和 throws 有什么区别</p><pre><code>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个Exception，如： </code></pre><p>throw new IllegalArgumentException(“XXXXXXXXX″)</p><pre><code>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</code></pre><p>50，java中会存在内存泄漏吗，请简单描述。</p><pre><code>先解释什么是内存泄漏：所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的。java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;41、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？&lt;br&gt;   hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equal
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips1 基础</title>
    <link href="http://yoursite.com/2019/10/31/Tips1-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/31/Tips1-基础/</id>
    <published>2019-10-31T02:20:38.000Z</published>
    <updated>2019-10-31T02:20:38.865Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8 组合设计模式</title>
    <link href="http://yoursite.com/2019/10/16/8-%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/16/8-组合设计模式/</id>
    <published>2019-10-16T09:31:30.000Z</published>
    <updated>2019-10-16T09:31:30.941Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>7 装饰者设计模式</title>
    <link href="http://yoursite.com/2019/10/14/7-%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/14/7-装饰者设计模式/</id>
    <published>2019-10-14T08:24:23.000Z</published>
    <updated>2019-10-15T09:44:17.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式介绍"><a href="#装饰者模式介绍" class="headerlink" title="装饰者模式介绍"></a>装饰者模式介绍</h1><p>装饰者模式就像打包一个快递<br>主体比如：陶瓷、衣服 (Component) // 被装饰者<br>包装 ：比如：报纸填充、塑料泡沫、纸板、木板 (<br>2)Component主体：比如类似前面的 Drink</p><p>3)ConcreteComponent 和 Decorator<br>ConcreteComponent ：具体的主体比如前面的各个单品咖啡<br>Decorator: 装饰者，比如各调料</p><p>4)在如图的 Component 与 ConcreteComponent 之间 ，如果<br>ConcreteComponent 类很多 还可以设计一个缓冲层，将共有的部分提取出来，<br>抽象层一个类 。<br><img src="https://upload-images.jianshu.io/upload_images/18958678-cd96308bd2f499a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/18958678-aff98dc0b4a3b6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public abstract class Drink &#123;</span><br><span class="line">    public String des;  //描述</span><br><span class="line">    private float price = 0.0f;</span><br><span class="line"></span><br><span class="line">    //计算费用的抽象方法，由子类实现</span><br><span class="line">    public abstract float cost();</span><br><span class="line"></span><br><span class="line">    public void setDes(String des) &#123;</span><br><span class="line">        this.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(float price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Coffee extends Drink &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        return super.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class ACoffee extends Coffee &#123;</span><br><span class="line">    public ACoffee() &#123;</span><br><span class="line">        setDes(&quot;A咖啡&quot;);</span><br><span class="line">        setPrice(6.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class BCoffee extends Coffee &#123;</span><br><span class="line">    public BCoffee() &#123;</span><br><span class="line">        setDes(&quot;B咖啡&quot;);</span><br><span class="line">        setPrice(7.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Decorator extends Drink &#123;</span><br><span class="line"></span><br><span class="line">    private Drink obj;</span><br><span class="line"></span><br><span class="line">    public Decorator(Drink obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        //getPrice 自己价格</span><br><span class="line">        return getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return des + &quot; &quot; + getPrice() + &quot; &amp;&amp; &quot; + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Chocolate extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public Chocolate(Drink obj) &#123;</span><br><span class="line">        super(obj);</span><br><span class="line">        setDes(&quot;巧克力&quot;);</span><br><span class="line">        setPrice(3.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Milk extends Decorator &#123;</span><br><span class="line">    public Milk(Drink obj) &#123;</span><br><span class="line">        super(obj);</span><br><span class="line">        setDes(&quot;牛奶&quot;);</span><br><span class="line">        setPrice(2.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //先点一份ACoffee</span><br><span class="line">        Drink order = new ACoffee();</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line"></span><br><span class="line">        //加入一份牛奶</span><br><span class="line">        order = new Milk(order);</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line"></span><br><span class="line">        //在加入一份巧克力</span><br><span class="line">        order = new Chocolate(order);</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">6.0</span><br><span class="line">A咖啡</span><br><span class="line">8.0</span><br><span class="line">牛奶 2.0 &amp;&amp; A咖啡</span><br><span class="line">11.0</span><br><span class="line">巧克力 3.0 &amp;&amp; 牛奶 2.0 &amp;&amp; A咖啡</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><img src="https://upload-images.jianshu.io/upload_images/18958678-ad874d8596feaf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/18958678-ee87dabb1f7063d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者模式介绍&quot;&gt;&lt;a href=&quot;#装饰者模式介绍&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式介绍&quot;&gt;&lt;/a&gt;装饰者模式介绍&lt;/h1&gt;&lt;p&gt;装饰者模式就像打包一个快递&lt;br&gt;主体比如：陶瓷、衣服 (Component) // 被装饰者&lt;br
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>6 桥接设计模式</title>
    <link href="http://yoursite.com/2019/10/13/6-%E6%A1%A5%E6%8E%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/13/6-桥接设计模式/</id>
    <published>2019-10-13T07:14:11.000Z</published>
    <updated>2019-10-14T08:23:58.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桥接模式-Bridge-基本介绍"><a href="#桥接模式-Bridge-基本介绍" class="headerlink" title="桥接模式 Bridge 基本介绍"></a>桥接模式 Bridge 基本介绍</h1><p>基本介绍<br>1)桥接模式 (Bridge模式是指 ：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。<br>2)是一种结构型设计模式<br>3)Bridge 模式基于类的最小设计原则 ，通过使用封装、聚合及继承等行为让不同<br>的类承担不同的职责。它的主要特点是把抽象 (与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展<br><img src="https://upload-images.jianshu.io/upload_images/18958678-654d4d41369f2ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">//接口</span><br><span class="line">public interface Brand &#123;</span><br><span class="line">    void open();</span><br><span class="line">    void close();</span><br><span class="line">    void call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class XiaoMi implements Brand&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;小米开机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;小米关机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;小米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class Vivo implements Brand&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo开机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo关机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public abstract class Phone &#123;</span><br><span class="line"></span><br><span class="line">    //聚合品牌</span><br><span class="line">    private Brand brand;</span><br><span class="line"></span><br><span class="line">    public Phone(Brand brand)&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void open()&#123;</span><br><span class="line">        brand.open();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void close()&#123;</span><br><span class="line">        brand.close();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void call()&#123;</span><br><span class="line">        brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class APhone extends Phone &#123;</span><br><span class="line">    public APhone(Brand brand) &#123;</span><br><span class="line">        super(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void open()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;A手机打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        super.close();</span><br><span class="line">        System.out.println(&quot;A手机关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void call()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;A手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class BPhone extends Phone &#123;</span><br><span class="line">    public BPhone(Brand brand) &#123;</span><br><span class="line">        super(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void open()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;B手机打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        super.close();</span><br><span class="line">        System.out.println(&quot;B手机关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void call()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;B手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone1 = new APhone(new XiaoMi());</span><br><span class="line">        phone1.call();</span><br><span class="line">        phone1.close();</span><br><span class="line">        phone1.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>桥接模式在JDBC中的应用<br><img src="https://upload-images.jianshu.io/upload_images/18958678-2c4fadc229e6ca8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桥接模式-Bridge-基本介绍&quot;&gt;&lt;a href=&quot;#桥接模式-Bridge-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;桥接模式 Bridge 基本介绍&quot;&gt;&lt;/a&gt;桥接模式 Bridge 基本介绍&lt;/h1&gt;&lt;p&gt;基本介绍&lt;br&gt;1)桥接模式
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>5 适配器设计模式</title>
    <link href="http://yoursite.com/2019/10/11/5-%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/11/5-适配器设计模式/</id>
    <published>2019-10-11T03:18:05.000Z</published>
    <updated>2019-10-13T06:56:36.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器<br>2)适配器 模式属于结构型模式<br>3)主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被适配的类</span><br><span class="line"> */</span><br><span class="line">public class Voltage220V &#123;</span><br><span class="line">    public int output220V()&#123;</span><br><span class="line">        //输出220V电压</span><br><span class="line">        int src = 220;</span><br><span class="line">        System.out.println(&quot;电压=&quot; + src + &quot;伏特&quot;);</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配接口</span><br><span class="line"> */</span><br><span class="line">public interface IVoltage5V &#123;</span><br><span class="line">    public int output5V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter extends Voltage220V implements IVoltage5V&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    //充电</span><br><span class="line">    public void charging(IVoltage5V iVoltage5V)&#123;</span><br><span class="line">        if (iVoltage5V.output5V() == 5) &#123;</span><br><span class="line">            System.out.println(&quot;电压为5V，正在充电&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;电压出错，无法充电&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类适配器模式注意事项和细节<br>1)Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点因为这要求dst必须是接口，有一定局限性.<br>2)src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本 。<br>3)由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得Adapter的灵活性增强了</p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>1)基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承src 类，而是持有 src 类的实例，以解决兼容性的问题。 即持有 src 类，实现 dst 类接口，完成src–&gt;dst 的适配<br>2)根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。<br>3)对象适配器模式是适配器模式常用的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter implements IVoltage5V&#123;</span><br><span class="line">    </span><br><span class="line">    private Voltage220V voltage220V;</span><br><span class="line">    </span><br><span class="line">    //不再集成，而是通过关联关系中的聚合</span><br><span class="line">    //即利用构造方法传入一个Voltage220V的实例</span><br><span class="line">    public VoltageAdapter(Voltage220V voltage220V) &#123;</span><br><span class="line">        this.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = voltage220V.output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter(new Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><p>1)一些书籍称为：适配器模式 (Default Adapter或缺省适配器模式<br>2)当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需 求<br>3)适用于一个接口不想使用其所有的方法的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface4 &#123;</span><br><span class="line">    public void m1();</span><br><span class="line">    public void m2();</span><br><span class="line">    public void m3();</span><br><span class="line">    public void m4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在抽象类中空实现所有方法</span><br><span class="line">public abstract class AbsAdapter implements Interface4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void m1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbsAdapter adapter = new AbsAdapter() &#123;</span><br><span class="line">            //只需覆盖我们需要使用的接口方法</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void m1() &#123;</span><br><span class="line">                System.out.println(&quot;使用了m1方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        adapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>适配器模式在SpringMVC框架应用<br><img src="https://upload-images.jianshu.io/upload_images/18958678-ed3140e11d339369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/18958678-a0cd9b8752ee4232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="适配器模式的注意事项和细节"><a href="#适配器模式的注意事项和细节" class="headerlink" title="适配器模式的注意事项和细节"></a>适配器模式的注意事项和细节</h1><p>1)三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来<br>命名的。<br>2)类适配器：以类给到，在 Adapter里，就是将 src 当做类，继承对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持 有接口适配 器：以 接口给到，在 Adapter 里，将 src 作为一个接口实现<br>3)Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>4 建造者设计模式</title>
    <link href="http://yoursite.com/2019/10/10/4-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/10/4-建造者设计模式/</id>
    <published>2019-10-10T07:21:12.000Z</published>
    <updated>2019-10-11T03:18:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1.适用场景：<br>1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果<br>2)多个部件都可以装配到一个对象中，但产生的运行结果不相同<br>3)产品类非常复杂或者产品类因为调用顺序不同而产生不同作用<br>4)初始化一个对象时，参数过多，或者很多参数具有默认值<br>5)Builder模式不适合创建差异性很大的产品类<br>6)产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本<br>7)需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</p><p>2.建造者模式的四个角色<br>1)Product （产品角色一个具体的产品对象 。<br>2)Builder （抽象建造者 创建一个Product对象的各个部件指定的接口抽象类 。<br>3)ConcreteBuilder （具体建造者实现接口，构建和装配各个部件 。<br>4)Director （指挥者 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。<br><img src="https://upload-images.jianshu.io/upload_images/18958678-732af724ba70d047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="具体对象"><a href="#具体对象" class="headerlink" title="具体对象"></a>具体对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">    private String baise;</span><br><span class="line">    private String wall;</span><br><span class="line">    private String roofed;</span><br><span class="line">//getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象的建造者</span><br><span class="line"> */</span><br><span class="line">public abstract class HouseBuilder &#123;</span><br><span class="line">    protected House house = new House();</span><br><span class="line"></span><br><span class="line">    //建造的抽象流程</span><br><span class="line">    public abstract void buildBasic();</span><br><span class="line">    public abstract void buildWalls();</span><br><span class="line">    public abstract void roofed();</span><br><span class="line"></span><br><span class="line">    //造好房子，将房子返回</span><br><span class="line">    public House buildHouse()&#123;</span><br><span class="line">        return house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CommonHouse extends HouseBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildBasic() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子打地基5米&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildWalls() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子建墙四堵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void roofed() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子造天花板&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指挥者</span><br><span class="line"> */</span><br><span class="line">public class HouseDirector &#123;</span><br><span class="line"></span><br><span class="line">    HouseBuilder houseBuilder = null;</span><br><span class="line"></span><br><span class="line">    //构造器传入houseBuilder</span><br><span class="line">    public HouseDirector(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过setter传入houseBuilder</span><br><span class="line">    public void setHouseBuilder(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指挥者指挥建造的房子的流程</span><br><span class="line">    public House constructHouse()&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        return houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //盖普通房子</span><br><span class="line">        CommonHouse commonHouse = new CommonHouse();</span><br><span class="line">        //准备指挥者</span><br><span class="line">        HouseDirector houseDirector = new HouseDirector(commonHouse);</span><br><span class="line">        //完成</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>建造者设计模式在JDK中java.lang.StringBuilder中的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client.java</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(&quot;sss&quot;);</span><br><span class="line"></span><br><span class="line">StringBuilder.java</span><br><span class="line">public final class StringBuilder</span><br><span class="line">extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder.java</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br></pre></td></tr></table></figure><p>1.Appendable接口定义了多个append抽象方法，所以Appendable为抽象建造者，定义了抽象方法；<br>2.AbstractStringBuilder实现了Appendable方法，所以AbstractStringBuilder是建造者，只是不能实例化<br>3.StringBuilder既是指挥者，又是具体的建造者，比如建造方法的实现是由 AbstractStringBuilder 完成 , 而 StringBuilder 继承了<br>AbstractStringBuilder。</p><p>4.建造者模式与抽象工厂模式的比较:<br>1)与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。<br>2)在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。<br>3)如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1.适用场景：&lt;br&gt;1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果&lt;br&gt;2)多个部件都可以装配
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3 原型模式</title>
    <link href="http://yoursite.com/2019/10/09/3-%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/09/3-原型设计模式/</id>
    <published>2019-10-09T06:58:29.000Z</published>
    <updated>2019-10-10T08:25:52.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>2)原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象无需知道如何创建的细节<br>3)工作原理是 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone。<br>4)二者只是属性相同，并不是同一个<br>5)对象.clone是浅拷贝<br>6)深克隆两种方法：1.重写clone方法。2.通过对象的序列化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Sheep implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sheep = (Sheep) super.clone();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return sheep;</span><br><span class="line">    &#125;</span><br><span class="line">//......</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = new Sheep(&quot;Tom&quot;, 1, &quot;White&quot;);</span><br><span class="line">        Sheep cloned1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned3 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned4 = (Sheep) sheep.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(cloned1);</span><br><span class="line">        System.out.println(cloned2);</span><br><span class="line">        System.out.println(cloned3);</span><br><span class="line">        System.out.println(cloned4);</span><br><span class="line">        System.out.println(cloned1==cloned2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h2><p>1)Spring 中原 型 bean 的创建，就是原型模式的应用,核心代码在doGetBean中对mdb.isSingleton()或者mdb.isPrototype之后，获取原型。<br>2)代码分析 +Debug 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beans.xml</span><br><span class="line">&lt;bean id= id=&quot;id01&quot; class=&quot;com.atguigu.spring.bean.Monster&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line">ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">//获取 monster[ 通过 id 获取 monster]</span><br><span class="line">Object bean = applicationContext.getBean(&quot;id01&quot;);</span><br><span class="line">System.out.println(&quot;bean&quot; + bean);</span><br></pre></td></tr></table></figure><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>数据类型分为两种基础类型和引用类型：<br>1、基础类型：像Number、String、Boolean等这种为基本类型<br>2、引用类型：Object和Array<br>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class Sheep implements Cloneable implements Serializable, Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line">    public DeepCloneableTarget deepCloneableTarget;</span><br><span class="line"></span><br><span class="line">    //方式一：重写clone方法</span><br><span class="line">    //1.基本类型，直接super处理，不用单独处理</span><br><span class="line">    //2.引用类型，对此直接调用该引用对象自身的clone方法</span><br><span class="line">    //这种方法真的要写需要递归，分支较大，复杂度不可预知，不推荐</span><br><span class="line"></span><br><span class="line">    //方式二：利用对象的序列化实现</span><br><span class="line">    public Object deepClone() &#123;</span><br><span class="line"></span><br><span class="line">        //创建流对象</span><br><span class="line">        ByteArrayOutputStream bos = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        ByteArrayInputStream bis = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            //序列化</span><br><span class="line">            bos = new ByteArrayOutputStream();</span><br><span class="line">            oos = new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this); //当前这个对象以对象流的方式输出</span><br><span class="line"></span><br><span class="line">            //反序列化</span><br><span class="line">            bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = new ObjectInputStream(bis);</span><br><span class="line">            Object copyObj = ois.readObject();</span><br><span class="line"></span><br><span class="line">            return copyObj;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭流</span><br><span class="line">            try &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;br&gt;2)原型
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3 原型设计模式</title>
    <link href="http://yoursite.com/2019/10/09/3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/09/3-原型模式/</id>
    <published>2019-10-09T06:58:29.000Z</published>
    <updated>2019-10-14T08:24:49.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>2)原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象无需知道如何创建的细节<br>3)工作原理是 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone。<br>4)二者只是属性相同，并不是同一个<br>5)对象.clone是浅拷贝<br>6)深克隆两种方法：1.重写clone方法。2.通过对象的序列化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Sheep implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sheep = (Sheep) super.clone();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return sheep;</span><br><span class="line">    &#125;</span><br><span class="line">//......</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = new Sheep(&quot;Tom&quot;, 1, &quot;White&quot;);</span><br><span class="line">        Sheep cloned1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned3 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned4 = (Sheep) sheep.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(cloned1);</span><br><span class="line">        System.out.println(cloned2);</span><br><span class="line">        System.out.println(cloned3);</span><br><span class="line">        System.out.println(cloned4);</span><br><span class="line">        System.out.println(cloned1==cloned2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h2><p>1)Spring 中原 型 bean 的创建，就是原型模式的应用,核心代码在doGetBean中对mdb.isSingleton()或者mdb.isPrototype之后，获取原型。<br>2)代码分析 +Debug 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beans.xml</span><br><span class="line">&lt;bean id= id=&quot;id01&quot; class=&quot;com.atguigu.spring.bean.Monster&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line">ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">//获取 monster[ 通过 id 获取 monster]</span><br><span class="line">Object bean = applicationContext.getBean(&quot;id01&quot;);</span><br><span class="line">System.out.println(&quot;bean&quot; + bean);</span><br></pre></td></tr></table></figure><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>数据类型分为两种基础类型和引用类型：<br>1、基础类型：像Number、String、Boolean等这种为基本类型<br>2、引用类型：Object和Array<br>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class Sheep implements Cloneable implements Serializable, Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line">    public DeepCloneableTarget deepCloneableTarget;</span><br><span class="line"></span><br><span class="line">    //方式一：重写clone方法</span><br><span class="line">    //1.基本类型，直接super处理，不用单独处理</span><br><span class="line">    //2.引用类型，对此直接调用该引用对象自身的clone方法</span><br><span class="line">    //这种方法真的要写需要递归，分支较大，复杂度不可预知，不推荐</span><br><span class="line"></span><br><span class="line">    //方式二：利用对象的序列化实现</span><br><span class="line">    public Object deepClone() &#123;</span><br><span class="line"></span><br><span class="line">        //创建流对象</span><br><span class="line">        ByteArrayOutputStream bos = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        ByteArrayInputStream bis = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            //序列化</span><br><span class="line">            bos = new ByteArrayOutputStream();</span><br><span class="line">            oos = new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this); //当前这个对象以对象流的方式输出</span><br><span class="line"></span><br><span class="line">            //反序列化</span><br><span class="line">            bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = new ObjectInputStream(bis);</span><br><span class="line">            Object copyObj = ois.readObject();</span><br><span class="line"></span><br><span class="line">            return copyObj;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭流</span><br><span class="line">            try &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;br&gt;2)原型
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2 工厂设计模式</title>
    <link href="http://yoursite.com/2019/09/27/2-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/27/2-工厂设计模式/</id>
    <published>2019-09-27T10:18:26.000Z</published>
    <updated>2019-10-10T09:30:45.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//披萨类</span><br><span class="line">public class Pizza &#123;</span><br><span class="line">    public void prepare1()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void prepare2()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void prepare3()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//GreekPizza</span><br><span class="line">public class GreekPizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare1() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare2() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare3() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//CheesePizza</span><br><span class="line">public class CheesePizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare1() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare2() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare3() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式（静态工厂）"><a href="#简单工厂模式（静态工厂）" class="headerlink" title="简单工厂模式（静态工厂）"></a>简单工厂模式（静态工厂）</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-79265d99dd87135b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFactory &#123;</span><br><span class="line">    public static Pizza createPizza(String OrderType)&#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line"></span><br><span class="line">        if (&quot;Greek&quot;.equals(OrderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(OrderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class OrderPizza &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pizza pizza = SimpleFactory.createPizza(&quot;Greek&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-9915dee5a21cd10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//OrderPizza抽象类</span><br><span class="line">public abstract class OrderPizza &#123;</span><br><span class="line">    abstract Pizza createPizza(String orderType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//北京店</span><br><span class="line">public class BJOrderPizza extends OrderPizza &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//伦敦店</span><br><span class="line">public class LDOrderPizza extends OrderPizza&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//主动订购</span><br><span class="line">public class PizzaStore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//自己选择去哪家店</span><br><span class="line">        BJOrderPizza bjOrderPizza = new BJOrderPizza();</span><br><span class="line">        Pizza pizza = bjOrderPizza.createPizza(&quot;Greek&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法模式"><a href="#抽象方法模式" class="headerlink" title="抽象方法模式"></a>抽象方法模式</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-06c6a92e3ead8136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbsFactory &#123;</span><br><span class="line">    public Pizza createPizza(String orderType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BJFactory implements AbsFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LDFactory implements AbsFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderPizza &#123;</span><br><span class="line">    public OrderPizza(AbsFactory absFactory) &#123;</span><br><span class="line">        setFactory(absFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setFactory(AbsFactory absFactory) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        //模拟定了cheese披萨</span><br><span class="line">        pizza = absFactory.createPizza(&quot;Cheese&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Cilent &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new OrderPizza(new BJFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>工厂方法就是让所有工厂实现了一个抽象方法（通过继承一个抽象类），这样所有的工厂都会生产汽车了，但是具体生产什么汽车还得自己去找对应的厂子。<br>抽象工厂模式就是，抽象出一个工厂接口，所有工厂实现这个接口，实现其中的制造方法，在使用的时候，任意抽象类工厂的实现类都可以被应用到这个位置，不用自己选择。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h1 id="在JDK源码中的应用"><a href="#在JDK源码中的应用" class="headerlink" title="在JDK源码中的应用"></a>在JDK源码中的应用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Calendar getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    Locale aLocale = Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">    return createCalendar(defaultTimeZone(aLocale), aLocale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private static Calendar createCalendar(TimeZone zone,</span><br><span class="line">                                       Locale aLocale)</span><br><span class="line">&#123;</span><br><span class="line">    CalendarProvider provider =</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                             .getCalendarProvider();</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">            // fall back to the default instantiation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal = null;</span><br><span class="line"></span><br><span class="line">    if (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">        if (caltype != null) &#123;</span><br><span class="line">//简单工厂模式</span><br><span class="line">            switch (caltype) &#123;</span><br><span class="line">            case &quot;buddhist&quot;:</span><br><span class="line">            cal = new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;japanese&quot;:</span><br><span class="line">                cal = new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;gregory&quot;:</span><br><span class="line">                cal = new GregorianCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cal == null) &#123;</span><br><span class="line">        // If no known calendar type is explicitly specified,</span><br><span class="line">        // perform the traditional way to create a Calendar:</span><br><span class="line">        // create a BuddhistCalendar for th_TH locale,</span><br><span class="line">        // a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">        // a GregorianCalendar for any other locales.</span><br><span class="line">        // NOTE: The language, country and variant strings are interned.</span><br><span class="line">        if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123;</span><br><span class="line">            cal = new BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;</span><br><span class="line">                   &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123;</span><br><span class="line">            cal = new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cal = new GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1 单例设计模式</title>
    <link href="http://yoursite.com/2019/09/27/1-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/27/1-单例设计模式/</id>
    <published>2019-09-27T09:37:57.000Z</published>
    <updated>2019-10-09T07:39:01.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h1 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3.懒汉式"></a>3.懒汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-懒汉式-同步方法"><a href="#4-懒汉式-同步方法" class="headerlink" title="4.懒汉式(同步方法)"></a>4.懒汉式(同步方法)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static synchronized Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-懒汉式（同步代码块）"><a href="#5-懒汉式（同步代码块）" class="headerlink" title="5.懒汉式（同步代码块）"></a>5.懒汉式（同步代码块）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(Singleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                        instance = new Singleton();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-双重检查"><a href="#6-双重检查" class="headerlink" title="6.双重检查"></a>6.双重检查</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(Singleton.class)&#123;</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7.静态内部类"></a>7.静态内部类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        private static class SingletonInstance &#123;</span><br><span class="line">            private static Singleton INSTANCE = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return SingletonInstance.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum  Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        public Singleton getInstance()&#123;</span><br><span class="line">            return INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h1 id="单例模式在JDK源码中的应用"><a href="#单例模式在JDK源码中的应用" class="headerlink" title="单例模式在JDK源码中的应用"></a>单例模式在JDK源码中的应用</h1><p>java.lang.Runtime就是经典的单例模式（饿汉式）<br><img src="https://upload-images.jianshu.io/upload_images/18958678-923a98d87b156357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h2&gt;&lt;h1 id=&quot;1-饿汉式（静态常量）&quot;&gt;&lt;a href=&quot;#1-饿汉式（静态常量）&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>依赖关系传递的三种方式</title>
    <link href="http://yoursite.com/2019/09/26/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/26/依赖关系传递的三种方式/</id>
    <published>2019-09-26T03:12:49.000Z</published>
    <updated>2019-09-26T03:57:57.371Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open(ITV itv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open(ITV itv) &#123;</span><br><span class="line">            itv.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose();</span><br><span class="line">        openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line">        public ITV tv;</span><br><span class="line"></span><br><span class="line">        public OpenAndClose(ITV tv) &#123;</span><br><span class="line">            this.tv = tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open() &#123;</span><br><span class="line">            this.tv.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open();</span><br><span class="line"></span><br><span class="line">        public void setTV(ITV tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line">        private ITV tv;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open() &#123;</span><br><span class="line">            this.tv.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setTV(ITV tv) &#123;</span><br><span class="line">            this.tv = tv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose();</span><br><span class="line">        openAndClose.setTV(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Spring源码阅读" scheme="http://yoursite.com/tags/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 36. 有效的数独</title>
    <link href="http://yoursite.com/2019/09/19/leetcode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>http://yoursite.com/2019/09/19/leetcode-36-有效的数独/</id>
    <published>2019-09-19T06:26:54.000Z</published>
    <updated>2019-09-19T06:28:10.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSudoku(char[][] board) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] rows = new HashMap[9];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] columns = new HashMap[9];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] boxes = new HashMap[9];</span><br><span class="line">        for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            rows[i] = new HashMap&lt;&gt;();</span><br><span class="line">            columns[i] = new HashMap&lt;&gt;();</span><br><span class="line">            boxes[i] = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">                char c = board[i][j];</span><br><span class="line">                if (c != &apos;.&apos;) &#123;</span><br><span class="line">                    int n = (int) c;</span><br><span class="line">                    int box_index = (i / 3) * 3 + j / 3;</span><br><span class="line"></span><br><span class="line">                    rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);</span><br><span class="line">                    columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);</span><br><span class="line">                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);</span><br><span class="line"></span><br><span class="line">                    if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;p&gt;数字 1-9 在每一行
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://yoursite.com/2019/09/18/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/09/18/leetcode-34-在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2019-09-18T04:30:25.000Z</published>
    <updated>2019-09-18T04:30:59.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] ints = new int[2];</span><br><span class="line">        if(nums.length == 0)&#123;</span><br><span class="line">            ints[0] = -1;</span><br><span class="line">            ints[1] = -1;</span><br><span class="line">            return  ints;</span><br><span class="line">        &#125;</span><br><span class="line">        ints[0] = left_bound(nums, target);</span><br><span class="line">        ints[1] = right_bound(nums, target);</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left_bound(int[] nums, int target) &#123;</span><br><span class="line">        if (nums.length == 0)&#123; return -1;&#125;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt;= nums.length - 1 &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int right_bound(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt;= 0 &amp;&amp; nums[right] == target)&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 33. 搜索旋转排序数组</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-33-搜索旋转排序数组/</id>
    <published>2019-09-17T06:09:26.000Z</published>
    <updated>2019-09-17T06:10:20.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:</p><p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int start = 0, end = nums.length - 1;</span><br><span class="line">        while (start &lt;= end) &#123;</span><br><span class="line">            int mid = (start + end) / 2;</span><br><span class="line">            if (nums[mid]==target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //前半部分有序,注意此处用小于等于</span><br><span class="line">            if (nums[start] &lt;= nums[mid]) &#123;</span><br><span class="line">                //target在前半部分</span><br><span class="line">                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 29. 两数相除</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-29-两数相除/</id>
    <published>2019-09-17T04:04:30.000Z</published>
    <updated>2019-09-17T04:07:07.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>说明:</p><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123;</span><br><span class="line">        if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;</span><br><span class="line">            return Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int flag = 1;</span><br><span class="line">        if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) &#123;</span><br><span class="line">            flag = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dividend &gt; 0) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        if (divisor &gt; 0) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (dividend &lt;= divisor) &#123;</span><br><span class="line">            int k = 1;</span><br><span class="line">            int tempDivisor = divisor;</span><br><span class="line">            //使用tempDivisor每次倍增，到达最大时，记录倍数</span><br><span class="line">            while (dividend &lt;= tempDivisor + tempDivisor &amp;&amp; tempDivisor + tempDivisor &lt; 0) &#123;</span><br><span class="line">                tempDivisor += tempDivisor;</span><br><span class="line">                k += k;</span><br><span class="line">            &#125;</span><br><span class="line">            //记录倍数，减去响应的部分，进行下一次较小的倍增</span><br><span class="line">            dividend -= tempDivisor;</span><br><span class="line">            count += k;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0 ? count : -count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>因为int存储范围，负数边界的绝对值比正数大，负数变成正数会越界，但是正数变成负数不会越界</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 24. 两两交换链表中的节点</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-24-两两交换链表中的节点/</id>
    <published>2019-09-17T03:05:07.000Z</published>
    <updated>2019-09-17T03:06:05.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = new ListNode(0);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        ListNode p1 = pre;</span><br><span class="line">        while (p1.next != null &amp;&amp; p1.next.next != null) &#123;</span><br><span class="line">            ListNode left = p1.next;</span><br><span class="line">            ListNode right = p1.next.next;</span><br><span class="line">            p1.next = right;</span><br><span class="line">            left.next = right.next;</span><br><span class="line">            right.next = left;</span><br><span class="line">            p1 = left;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 22. 括号生成</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-22-括号生成/</id>
    <published>2019-09-16T09:04:24.000Z</published>
    <updated>2019-09-16T09:10:20.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        getIt(&quot;&quot;, n, 0, 0);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getIt(String s, int n, int open, int close) &#123;</span><br><span class="line">        if (s.length() == 2 * n) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if (open &lt; n) &#123;</span><br><span class="line">            getIt(s + &quot;(&quot;, n, open + 1, close);</span><br><span class="line">        &#125;</span><br><span class="line">        if (open &gt; close) &#123;</span><br><span class="line">            getIt(s + &quot;)&quot;, n, open, close + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>添加括号两种情况<br>1.能添加n个左括号，还没加完。<br>2.能添加右括号，从而使它与前面的左括号闭合，即open&gt;close。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 n =
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 19. 删除链表的倒数第N个节点</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-19-删除链表的倒数第N个节点/</id>
    <published>2019-09-16T08:39:15.000Z</published>
    <updated>2019-09-16T08:40:53.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode pre = new ListNode(0);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        ListNode left = pre;</span><br><span class="line">        ListNode right = pre;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right.next != null) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>使用right.next != null保证right指针指向最后一个元素时结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.&lt;/p&gt;
&lt;p&gt;当删除了倒数第二个节点
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 18. 四数之和</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-18-四数之和/</id>
    <published>2019-09-16T06:37:49.000Z</published>
    <updated>2019-09-17T03:05:50.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    //基本思想：k个数的和,先固定k-2个数的位置，通过分层for循环</span><br><span class="line">    //最后通过k=2的时候选出符合条件的进行返回</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (nums.length &lt; 4) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res = kSum(nums, target, 4, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int nums[], int target, int k, int start) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (start &gt;= nums.length) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 2) &#123;</span><br><span class="line">            int left = start;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[left] + nums[right];</span><br><span class="line">                if (sum == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    //去重</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &gt; 2) &#123;</span><br><span class="line">            for (int i = start; i &lt; nums.length - k + 1; i++) &#123;</span><br><span class="line">                ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k - 1, i + 1);</span><br><span class="line">                if (temp != null) &#123;</span><br><span class="line">                    for (List&lt;Integer&gt; e : temp) &#123;</span><br><span class="line">                        e.add(0, nums[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.addAll(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>//此处不用asList，因为asList是一个私有内部类，并不是我们常用的Arraylist<br>//其没有重写add，remove方法，所以只能用于最后一步添加使用<br>//res.add(Arrays.asList(nums[left], nums[right]));</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
