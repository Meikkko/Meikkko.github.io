<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-25T06:13:35.323Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法框架集合</title>
    <link href="http://yoursite.com/2020/07/25/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/07/25/算法框架集合/</id>
    <published>2020-07-25T05:26:04.000Z</published>
    <updated>2020-07-25T06:13:35.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//遍历链表</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public void traverse1(ListNode head) &#123;</span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">//            迭代操作</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void traverse2(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">//          处理null      </span><br><span class="line">        &#125;</span><br><span class="line">//        递归操作</span><br><span class="line">        traverse2(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//遍历链表</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void traverse1(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">//            处理null</span><br><span class="line">        &#125;</span><br><span class="line">//        前序遍历</span><br><span class="line">        traverse1(root.left);</span><br><span class="line">//        中序遍历</span><br><span class="line">        traverse1(root.right);</span><br><span class="line">//        后序遍历</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="N叉树遍历"><a href="#N叉树遍历" class="headerlink" title="N叉树遍历"></a>N叉树遍历</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    for (TreeNode child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 计算从起点 start 到终点 target 的最近距离</span><br><span class="line">int BFS(Node start, Node target) &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; // 核心数据结构</span><br><span class="line">    Set&lt;Node&gt; visited; // 避免走回头路</span><br><span class="line"></span><br><span class="line">    q.offer(start); // 将起点加入队列</span><br><span class="line">    visited.add(start);</span><br><span class="line">    int step = 0; // 记录扩散的步数</span><br><span class="line"></span><br><span class="line">    while (q not empty) &#123;</span><br><span class="line">        int sz = q.size();</span><br><span class="line">        /* 将当前队列中的所有节点向四周扩散 */</span><br><span class="line">        for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            /* 划重点：这里判断是否到达终点 */</span><br><span class="line">            if (cur is target)</span><br><span class="line">                return step;</span><br><span class="line">            /* 将 cur 的相邻节点加入队列 */</span><br><span class="line">            for (Node x : cur.adj())</span><br><span class="line">                if (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 划重点：更新步数在这里 */</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) &gt;&gt; 1;</span><br><span class="line">            if (target == nums[mid]) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int left = 0, right = 0;</span><br><span class="line"></span><br><span class="line">while (right &lt; s.size()) &#123;`</span><br><span class="line">    // 增大窗口</span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    while (window needs shrink) &#123;</span><br><span class="line">        // 缩小窗口</span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;遍历链表&quot;&gt;&lt;a href=&quot;#遍历链表&quot; class=&quot;headerlink&quot; title=&quot;遍历链表&quot;&gt;&lt;/a&gt;遍历链表&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://yoursite.com/2020/06/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/11/背包问题/</id>
    <published>2020-06-11T04:54:06.000Z</published>
    <updated>2020-06-12T07:35:15.916Z</updated>
    
    <content type="html"><![CDATA[<p>01背包问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int maxSubArray(int number, int capacity, int[] weight, int[] value) &#123;</span><br><span class="line">        int[][] dp = new int[number + 1][capacity + 1];</span><br><span class="line">        for (int i = 0; i &lt; number + 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; capacity + 1; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                &#125; else if (j == 0) &#123;</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (j &lt; weight[i-1]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - 1][j];// 包的容量比当前该物品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i-1]] + value[i-1]);// 还有足够的容量可以装当前该物品，但装了当前物品也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[number][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 3, W = 4;</span><br><span class="line">        int[] wt = &#123;2, 1, 3&#125;;</span><br><span class="line">        int[] val = &#123;4, 2, 3&#125;;</span><br><span class="line">        System.out.println(maxSubArray(N, W, wt, val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/" title="子集背包问题" target="_blank" rel="noopener">子集背包问题</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= 2;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        boolean[][] dp = new boolean[n + 1][sum + 1];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n + 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; sum + 1; j++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125; else if (j == 0) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if (j &lt; nums[i-1]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - 1][j];</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i-1]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;01背包问题&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tips14 JavaWeb</title>
    <link href="http://yoursite.com/2019/11/28/Tips14-JavaWeb/"/>
    <id>http://yoursite.com/2019/11/28/Tips14-JavaWeb/</id>
    <published>2019-11-28T04:09:32.000Z</published>
    <updated>2019-11-28T04:53:45.395Z</updated>
    
    <content type="html"><![CDATA[<p>148，AJAX有哪些有点和缺点？</p><p>优点：</p><p>   1、最大的一点是页面无刷新，用户的体验非常好。</p><p>   2、使用异步方式与服务器通信，具有更加迅速的响应能力。</p><p>   3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</p><p>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p><p>缺点：</p><p>   1、ajax不支持浏览器back按钮。</p><p>   2、安全问题 AJAX暴露了与服务器交互的细节。</p><p>   3、对搜索引擎的支持比较弱。</p><p>   4、破坏了程序的异常机制。</p><p>   5、不容易调试。</p><p>149，AJAX应用和传统Web应用有什么不同？</p><p>   在传统的Javascript编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击”Submit”按钮来发送或者接受数据信息，然后等待服务器响应请求，页面重新加载。</p><p>   因为服务器每次都会返回一个新的页面， 所以传统的web应用有可能很慢而且用户交互不友好。</p><p>   使用AJAX技术， 就可以使Javascript通过XMLHttpRequest对象直接与服务器进行交互。</p><p>   通过HTTP Request， 一个web页面可以发送一个请求到web服务器并且接受web服务器返回的信息(不用重新加载页面)，展示给用户的还是同一个页面，用户感觉页面刷新，也看不到到Javascript后台进行的发送请求和接受响应，体验非常好。</p><p>150，Ajax的实现流程是怎样的？</p><p>   (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p><p>   (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p><p>   (3)设置响应HTTP请求状态变化的函数.</p><p>   (4)发送HTTP请求.</p><p>   (5)获取异步调用返回的数据.</p><p>   (6)使用JavaScript和DOM实现局部刷新.</p><p>具体一点：</p><p>1，创建XNLHttpRequest对象</p><p>（不考虑ie）XMLHttpRequest request = new XMLHttprequest（）；</p><p>2，创建新的Http请求</p><p>XMLHttprequest.open（method,url,flag,name,password）;</p><p>3，设置响应Http请求变化的函数</p><p>XMLHttprequest.onreadystatechange=getData;</p><p>function getData(){</p><p>if(XMLHttprequest.readyState==4){</p><p>获取数据</p><pre><code>}</code></pre><p> }</p><p>4，发送http请求</p><p>XMLHttprequest.send(data)；</p><p>5，获取异步调用返回的对象</p><p>，function(data){</p><p>//异步提交后，交互成功，返回的data便是异步调用返回的对象，该对象是一个string类型的</p><p>}</p><p>6，使用js、DOM实现局部刷新</p><p>myDiv.innerHTML=’’这是刷新后的数据’’</p><p>151，简单说一下数据库的三范式？</p><p>   第一范式：数据库表的每一个字段都是不可分割的</p><p>   第二范式：数据库表中的非主属性只依赖于主键</p><p>   第三范式：不存在非主属性对关键字的传递函数依赖关系</p><p>152，Java集合框架是什么？说出一些集合框架的优点？</p><p>   每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。</p><p>   随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。</p><p>   集合框架的部分优点如下：</p><p>（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。</p><p>（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。</p><p>（3）通过使用JDK附带的集合类，可以降低代码维护成本。</p><p>（4）复用性和可操作性。</p><p>153，Java集合框架的基础接口有哪些？</p><p>   Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。</p><p>   Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p><p>   List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。</p><p>   Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。</p><p> 一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p><p>154，集合框架中的泛型有什么优点？</p><p>   Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。</p><p>   因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。</p><p>   泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p><p>155，Enumeration和Iterator接口的区别？</p><pre><code>Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。</code></pre><p>156，Iterater和ListIterator之间有什么区别？</p><pre><code>1，我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。2，Iterator只可以向前遍历，而LIstIterator可以双向遍历。3，ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</code></pre><p>157，我们如何对一组对象进行排序？</p><pre><code>如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</code></pre><p>158，与Java集合框架相关的有哪些最好的实践？</p><pre><code>1，根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。2，一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。3，基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。4，总是使用类型安全的泛型，避免在运行时出现ClassCastException。5，使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。6，尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</code></pre><p>159，什么是事务？,</p><p>事务是恢复和并发控制的基本单位</p><p>事务的四个基本特征</p><p>原子性，一致性，隔离性，持久性</p><p>原子性和一致性差不多，意思是要么全部成功，要么就失败</p><p>一致性是说，从一个一致性状态到另一个一致性状态</p><p>隔离性是说一个事务执行的过程中不能被另一个事务干扰</p><p>持久性也就是事务一旦提交，他对数据库中数据的改变就应该是永久的，不能变的（这里只是面试简单的说一下理解，详细理解问度娘）</p><p>160，说说你开发中遇到过什么难题啊？怎么解决的？</p><p>卒…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;148，AJAX有哪些有点和缺点？&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;   1、最大的一点是页面无刷新，用户的体验非常好。&lt;/p&gt;
&lt;p&gt;   2、使用异步方式与服务器通信，具有更加迅速的响应能力。&lt;/p&gt;
&lt;p&gt;   3、可以把以前一些服务器负担的工作转嫁到客户端，利用
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips13 泛型</title>
    <link href="http://yoursite.com/2019/11/25/Tips13-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/11/25/Tips13-泛型/</id>
    <published>2019-11-25T07:08:02.000Z</published>
    <updated>2019-11-25T09:06:27.420Z</updated>
    
    <content type="html"><![CDATA[<ol start="139"><li><p>Java中的泛型是什么 ? 使用泛型的好处是什么?</p><p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p></li></ol><p>好处：</p><p>   1、类型安全，提供编译期间的类型检测</p><p>   2、前后兼容</p><p>   3、泛化代码,代码可以更多的重复利用</p><p>   4、性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件。</p><p> <a href="https://www.javazhiyin.com/49432.html" target="_blank" rel="noopener">https://www.javazhiyin.com/49432.html</a></p><p>140，Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？</p><p>   1、类型检查：在生成字节码之前提供类型检查</p><p>   2、类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）</p><p>   3、如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决</p><p>   4、如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换</p><p>类型擦除：</p><p>   所有类型参数都用他们的限定类型替换：</p><p>比如T-&gt;Object   ? extends BaseClass-&gt;BaseClass</p><p>如何工作：</p><p>   泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List<string>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。</string></p><p>141，你可以把List<string>传递给一个接受List<object>参数的方法吗？</object></string></p><p>   对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List<string>应当可以用在需要List<object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List<object>可以存储任何类型的对象包括String, Integer等等，而List<string>却只能用来存储String s。</string></object></object></string></p><p>List<object> objectList;</object></p><p>List<string> stringList;</string></p><p>objectList = stringList; //compilation error incompatible types</p><p>142，如何阻止Java中的类型未检查的警告?</p><p>   如果你把泛型和原始类型混合起来使用，例如下列代码，java 5的javac编译器会产生类型未检查的警告，例如</p><p>List<string> rawList = newArrayList()</string></p><p>注意: Hello.java使用了未检查或称为不安全的操作;</p><p>这种警告可以使用@SuppressWarnings(“unchecked”)注解来屏蔽。</p><p>143，Java中List<object>和原始类型List之间的区别?</object></p><p>   原始类型和带参数类型<object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。</object></p><p>   这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<string>传递给接受 List<object>的方法，因为会产生编译错误。</object></string></p><p>144，编写一段泛型程序来实现LRU缓存?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">public LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">  private int cacheSize;</span><br><span class="line"> </span><br><span class="line">  public LRUCache(int cacheSize) &#123;</span><br><span class="line">    super(16, 0.75, true);</span><br><span class="line">    this.cacheSize = cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">    return size() &gt;= cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>145，Array中可以用泛型吗?</p><p>   这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p><p>146，如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p><p>   编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。最简单的情况下，一个泛型方法可能会像这样：</p><p>   public V put(K key, V value) {</p><p>   return cahe.put(key,value);</p><p>}</p><p>147，C++模板和java泛型之间有何不同？</p><p>   java泛型实现根植于“类型消除”这一概念。当源代码被转换为Java虚拟机字节码时，这种技术会消除参数化类型。有了Java泛型，我们可以做的事情也并没有真正改变多少；他只是让代码变得漂亮些。鉴于此，Java泛型有时也被称为“语法糖”。</p><p>   这和 C++模板截然不同。在 C++中，模板本质上就是一套宏指令集，只是换了个名头，编译器会针对每种类型创建一份模板代码的副本。</p><p>由于架构设计上的差异，Java泛型和C++模板有很多不同点：</p><ol><li><p>C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer</p></li><li><p>Java中，可以将模板的类型参数限定为某种特定类型。例如，你可能会使用泛型实现CardDeck，并规定参数必须扩展自CardGame。</p></li><li><p>C++中，类型参数可以实例化，Java不可以实例化</p></li><li><p>Java中，类型参数（即MyClass<foo>中的Foo）不能用于静态方法和变量，因为他们会被MyClass<foo>和MyClass<bar>共享。但在C++中，这些类是不同的，类型参数可以用于静态方法和静态变量。</bar></foo></foo></p></li><li><p>在Java中，不管类型参数是什么，MyClass的所有实例都是同一类型。类型参数会在运行时被抹去。而C++中，参数类型不同，实例类型也不同</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;139&quot;&gt;
&lt;li&gt;&lt;p&gt;Java中的泛型是什么 ? 使用泛型的好处是什么?&lt;/p&gt;
&lt;p&gt;泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips12 Java多线程</title>
    <link href="http://yoursite.com/2019/11/12/Tips12-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/12/Tips12-Java多线程/</id>
    <published>2019-11-12T06:14:37.000Z</published>
    <updated>2019-11-12T13:11:18.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121，什么是线程？"><a href="#121，什么是线程？" class="headerlink" title="121，什么是线程？"></a>121，什么是线程？</h1><p>   线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。</p><h1 id="122，线程和进程有什么区别？"><a href="#122，线程和进程有什么区别？" class="headerlink" title="122，线程和进程有什么区别？"></a>122，线程和进程有什么区别？</h1><p>   线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。</p><h1 id="123，如何在Java中实现线程？"><a href="#123，如何在Java中实现线程？" class="headerlink" title="123，如何在Java中实现线程？"></a>123，如何在Java中实现线程？</h1><p>   <a href="https://blog.csdn.net/weixin_34315189/article/details/88678355" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34315189/article/details/88678355</a><br>   两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<br>   方法一：继承 Thread 类，覆盖方法 run()，我们在创建的 Thread 类的子类中重写 run() ,加入线程所要执行的代码即可。<br>   方法二：实现 Runnable 接口</p><h1 id="124，Java-关键字volatile-与-synchronized-作用与区别？"><a href="#124，Java-关键字volatile-与-synchronized-作用与区别？" class="headerlink" title="124，Java 关键字volatile 与 synchronized 作用与区别？"></a>124，Java 关键字volatile 与 synchronized 作用与区别？</h1><p>   1，volatile<br>   它所修饰的变量不保留拷贝，直接访问主内存中的。<br>   在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变 量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。</p><p>   2，synchronized<br>   <a href="https://www.cnblogs.com/firstdream/p/8334149.html" target="_blank" rel="noopener">https://www.cnblogs.com/firstdream/p/8334149.html</a><br>   <a href="https://blog.csdn.net/weixin_44127579/article/details/89861977" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44127579/article/details/89861977</a><br>   当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。<br>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>五、以上规则对其它对象锁同样适用.</p><h1 id="125，有哪些不同的线程生命周期？"><a href="#125，有哪些不同的线程生命周期？" class="headerlink" title="125，有哪些不同的线程生命周期？"></a>125，有哪些不同的线程生命周期？</h1><p><a href="https://blog.csdn.net/houbin0912/article/details/77969563" target="_blank" rel="noopener">https://blog.csdn.net/houbin0912/article/details/77969563</a><br>   当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。</p><h1 id="126，你对线程优先级的理解是什么？"><a href="#126，你对线程优先级的理解是什么？" class="headerlink" title="126，你对线程优先级的理解是什么？"></a>126，你对线程优先级的理解是什么？</h1><p>   每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><h1 id="127，什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#127，什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="127，什么是死锁(Deadlock)？如何分析和避免死锁？"></a>127，什么是死锁(Deadlock)？如何分析和避免死锁？</h1><ul><li><p>线程Thread1率先占有了resource1, 继续运行时需要resource2, 但此时resource2却被线程Thread2占有了， </p></li><li><p>因此只能等待Thread2释放resource2才能够继续运行； 同时，Thread2也需要resource1, </p></li><li><p>它只能等待Thread1释放resource1才能够继续运行， 因此，Thread1和Thread2都处于等待状态， </p><p> 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p><p> 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。</p><p> 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p></li></ul><h1 id="128，什么是线程安全？Vector是一个线程安全类吗？"><a href="#128，什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="128，什么是线程安全？Vector是一个线程安全类吗？"></a>128，什么是线程安全？Vector是一个线程安全类吗？</h1><p>   如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p><h1 id="129，Java中如何停止一个线程？"><a href="#129，Java中如何停止一个线程？" class="headerlink" title="129，Java中如何停止一个线程？"></a>129，Java中如何停止一个线程？</h1><p>   ava提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程</p><h1 id="130，什么是ThreadLocal"><a href="#130，什么是ThreadLocal" class="headerlink" title="130，什么是ThreadLocal?"></a>130，什么是ThreadLocal?</h1><p><a href="https://blog.csdn.net/woshiluoye9/article/details/72544764" target="_blank" rel="noopener">https://blog.csdn.net/woshiluoye9/article/details/72544764</a><br>   ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</p><p>   每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。</p><h1 id="131，Sleep-、suspend-和wait-之间有什么区别？"><a href="#131，Sleep-、suspend-和wait-之间有什么区别？" class="headerlink" title="131，Sleep()、suspend()和wait()之间有什么区别？"></a>131，Sleep()、suspend()和wait()之间有什么区别？</h1><p>   Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。</p><p>   注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。</p><p>   object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()/notify()与sleep()/interrupt()类似，只是前者需要获取对象锁。</p><h1 id="132，什么是线程饿死，什么是活锁？"><a href="#132，什么是线程饿死，什么是活锁？" class="headerlink" title="132，什么是线程饿死，什么是活锁？"></a>132，什么是线程饿死，什么是活锁？</h1><p>   当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：</p><p>   1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。</p><p>   2，当所有线程卡在无限循环中。</p><h1 id="133，什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#133，什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="133，什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>133，什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h1><p>   java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。</p><p>   java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p><h1 id="134，Java中的同步集合与并发集合有什么区别？"><a href="#134，Java中的同步集合与并发集合有什么区别？" class="headerlink" title="134，Java中的同步集合与并发集合有什么区别？"></a>134，Java中的同步集合与并发集合有什么区别？</h1><p>   同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。</p><p>   在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。</p><p>   Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和    内部分区等现代技术提高了可扩展性。</p><h1 id="135，同步方法和同步块，哪个是更好的选择？"><a href="#135，同步方法和同步块，哪个是更好的选择？" class="headerlink" title="135，同步方法和同步块，哪个是更好的选择？"></a>135，同步方法和同步块，哪个是更好的选择？</h1><p>   同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><h1 id="136，什么是线程池？-为什么要使用它？"><a href="#136，什么是线程池？-为什么要使用它？" class="headerlink" title="136，什么是线程池？ 为什么要使用它？"></a>136，什么是线程池？ 为什么要使用它？</h1><p>   创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。</p><p>   为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。</p><p>   从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。</p><h1 id="137，Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#137，Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="137，Java中invokeAndWait 和 invokeLater有什么区别？"></a>137，Java中invokeAndWait 和 invokeLater有什么区别？</h1><p>   这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p><h1 id="138，多线程中的忙循环是什么"><a href="#138，多线程中的忙循环是什么" class="headerlink" title="138，多线程中的忙循环是什么?"></a>138，多线程中的忙循环是什么?</h1><p>   忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。</p><p>   在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;121，什么是线程？&quot;&gt;&lt;a href=&quot;#121，什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;121，什么是线程？&quot;&gt;&lt;/a&gt;121，什么是线程？&lt;/h1&gt;&lt;p&gt;   线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips11 数据库</title>
    <link href="http://yoursite.com/2019/11/12/Tips11-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/11/12/Tips11-数据库/</id>
    <published>2019-11-12T06:05:00.000Z</published>
    <updated>2019-11-12T06:11:44.027Z</updated>
    
    <content type="html"><![CDATA[<p>作为一枚Java后端开发者，数据库知识必不可少，对数据库的掌握熟悉度的考察也是对这个人是否有扎实基本功的考察。特别对于初级开发者，面试可能不会去问框架相关知识，但是绝对不会不去考察数据库知识，这里收集一些常见类型的SQL语句，无论对于平常开发还是准备面试，都会有助益。</p><p>基本表结构：<br>   student(sno,sname,sage,ssex)学生表<br>   course(cno,cname,tno) 课程表<br>   sc(sno,cno,score) 成绩表<br>   teacher(tno,tname) 教师表</p><h1 id="101，查询课程1的成绩比课程2的成绩高的所有学生的学号"><a href="#101，查询课程1的成绩比课程2的成绩高的所有学生的学号" class="headerlink" title="101，查询课程1的成绩比课程2的成绩高的所有学生的学号"></a>101，查询课程1的成绩比课程2的成绩高的所有学生的学号</h1><p>select a.sno from<br>(select sno,score from sc where cno=1) a,<br>(select sno,score from sc where cno=2) b<br>where a.score&gt;b.score and a.sno=b.sno</p><h1 id="102，查询平均成绩大于60分的同学的学号和平均成绩"><a href="#102，查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="102，查询平均成绩大于60分的同学的学号和平均成绩"></a>102，查询平均成绩大于60分的同学的学号和平均成绩</h1><p>select a.sno as “学号”, avg(a.score) as “平均成绩”<br>from<br>(select sno,score from sc) a<br>group by sno having avg(a.score)&gt;60</p><h1 id="103，查询所有同学的学号、姓名、选课数、总成绩"><a href="#103，查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="103，查询所有同学的学号、姓名、选课数、总成绩"></a>103，查询所有同学的学号、姓名、选课数、总成绩</h1><p>select a.sno as 学号, b.sname as 姓名,<br>count(a.cno) as 选课数, sum(a.score) as 总成绩<br>from sc a, student b<br>where a.sno = b.sno<br>group by a.sno, b.sname</p><p>或者：</p><p>selectstudent.sno as 学号, student.sname as 姓名,<br> count(sc.cno) as 选课数, sum(score) as 总成绩<br>from student left Outer join sc on student.sno = sc.sno<br>group by student.sno, sname</p><h1 id="104，查询姓“张”的老师的个数"><a href="#104，查询姓“张”的老师的个数" class="headerlink" title="104，查询姓“张”的老师的个数"></a>104，查询姓“张”的老师的个数</h1><p>selectcount(distinct(tname)) from teacher where tname like ‘张%‘<br>或者：<br>select tname as “姓名”, count(distinct(tname)) as “人数”<br>from teacher<br>where tname like’张%’<br>group by tname</p><h1 id="105，查询没学过“张三”老师课的同学的学号、姓名"><a href="#105，查询没学过“张三”老师课的同学的学号、姓名" class="headerlink" title="105，查询没学过“张三”老师课的同学的学号、姓名"></a>105，查询没学过“张三”老师课的同学的学号、姓名</h1><p>select student.sno,student.sname from student<br>where sno not in (select distinct(sc.sno) from sc,course,teacher<br>where sc.cno=course.cno and teacher.tno=course.tno and teacher.tname=’张三’)</p><h1 id="106，查询同时学过课程1和课程2的同学的学号、姓名"><a href="#106，查询同时学过课程1和课程2的同学的学号、姓名" class="headerlink" title="106，查询同时学过课程1和课程2的同学的学号、姓名"></a>106，查询同时学过课程1和课程2的同学的学号、姓名</h1><p>select sno, sname from student<br>where sno in (select sno from sc where sc.cno = 1)<br>and sno in (select sno from sc where sc.cno = 2)<br>或者：</p><p>selectc.sno, c.sname from<br>(select sno from sc where sc.cno = 1) a,<br>(select sno from sc where sc.cno = 2) b,<br>student c<br>where a.sno = b.sno and a.sno = c.sno<br>或者：</p><p>select student.sno,student.sname from student,sc where student.sno=sc.sno and sc.cno=1<br>and exists( select * from sc as sc_2 where sc_2.sno=sc.sno and sc_2.cno=2)</p><h1 id="107，查询学过“李四”老师所教所有课程的所有同学的学号、姓名"><a href="#107，查询学过“李四”老师所教所有课程的所有同学的学号、姓名" class="headerlink" title="107，查询学过“李四”老师所教所有课程的所有同学的学号、姓名"></a>107，查询学过“李四”老师所教所有课程的所有同学的学号、姓名</h1><p>select a.sno, a.sname from student a, sc b<br>where a.sno = b.sno and b.cno in<br>(select c.cno from course c, teacher d where c.tno = d.tno and d.tname = ‘李四’)</p><p>或者：</p><p>select a.sno, a.sname from student a, sc b,<br>(select c.cno from course c, teacher d where c.tno = d.tno and d.tname = ‘李四’) e<br>where a.sno = b.sno and b.cno = e.cno</p><h1 id="108，查询课程编号1的成绩比课程编号2的成绩高的所有同学的学号、姓名"><a href="#108，查询课程编号1的成绩比课程编号2的成绩高的所有同学的学号、姓名" class="headerlink" title="108，查询课程编号1的成绩比课程编号2的成绩高的所有同学的学号、姓名"></a>108，查询课程编号1的成绩比课程编号2的成绩高的所有同学的学号、姓名</h1><p>select a.sno, a.sname from student a,<br>(select sno, score from sc where cno = 1) b,<br>(select sno, score from sc where cno = 2) c<br>where b.score &gt; c.score and b.sno = c.sno and a.sno = b.sno</p><h1 id="109，查询所有课程成绩小于60分的同学的学号、姓名"><a href="#109，查询所有课程成绩小于60分的同学的学号、姓名" class="headerlink" title="109，查询所有课程成绩小于60分的同学的学号、姓名"></a>109，查询所有课程成绩小于60分的同学的学号、姓名</h1><p>select sno,sname from student<br>where sno not in (select distinct sno from sc where score &gt; 60)</p><h1 id="110，查询至少有一门课程与学号为1的同学所学课程相同的同学的学号和姓名"><a href="#110，查询至少有一门课程与学号为1的同学所学课程相同的同学的学号和姓名" class="headerlink" title="110，查询至少有一门课程与学号为1的同学所学课程相同的同学的学号和姓名"></a>110，查询至少有一门课程与学号为1的同学所学课程相同的同学的学号和姓名</h1><p>select distinct a.sno, a.sname<br>from student a, sc b<br>where a.sno &lt;&gt; 1 and a.sno=b.sno and<br>b.cno in (select cno from sc where sno = 1)</p><p>或者：</p><p>select s.sno,s.sname<br>from student s,<br>(select sc.sno<br>from sc<br>where sc.cno in (select sc1.cno from sc sc1 where sc1.sno=1)and sc.sno&lt;&gt;1<br>group by sc.sno)r1<br>where r1.sno=s.sno</p><h1 id="111、把“sc”表中“王五”所教课的成绩都更改为此课程的平均成绩"><a href="#111、把“sc”表中“王五”所教课的成绩都更改为此课程的平均成绩" class="headerlink" title="111、把“sc”表中“王五”所教课的成绩都更改为此课程的平均成绩"></a>111、把“sc”表中“王五”所教课的成绩都更改为此课程的平均成绩</h1><p>update sc set score = (select avg(sc_2.score) from sc sc_2 wheresc_2.cno=sc.cno)<br>from course,teacher where course.cno=sc.cno and course.tno=teacher.tno andteacher.tname=’王五’</p><h1 id="112、查询和编号为2的同学学习的课程完全相同的其他同学学号和姓名"><a href="#112、查询和编号为2的同学学习的课程完全相同的其他同学学号和姓名" class="headerlink" title="112、查询和编号为2的同学学习的课程完全相同的其他同学学号和姓名"></a>112、查询和编号为2的同学学习的课程完全相同的其他同学学号和姓名</h1><p>这一题分两步查：</p><p>1，</p><p>select sno<br>from sc<br>where sno &lt;&gt; 2<br>group by sno<br>having sum(cno) = (select sum(cno) from sc where sno = 2)</p><p>2，<br>select b.sno, b.sname<br>from sc a, student b<br>where b.sno &lt;&gt; 2 and a.sno = b.sno<br>group by b.sno, b.sname<br>having sum(cno) = (select sum(cno) from sc where sno = 2)</p><h1 id="113、删除学习“王五”老师课的sc表记录"><a href="#113、删除学习“王五”老师课的sc表记录" class="headerlink" title="113、删除学习“王五”老师课的sc表记录"></a>113、删除学习“王五”老师课的sc表记录</h1><p>delete sc from course, teacher<br>where course.cno = sc.cno and course.tno = teacher.tno and tname = ‘王五’</p><h1 id="114、向sc表中插入一些记录，这些记录要求符合以下条件："><a href="#114、向sc表中插入一些记录，这些记录要求符合以下条件：" class="headerlink" title="114、向sc表中插入一些记录，这些记录要求符合以下条件："></a>114、向sc表中插入一些记录，这些记录要求符合以下条件：</h1><p>将没有课程3成绩同学的该成绩补齐, 其成绩取所有学生的课程2的平均成绩<br>insert sc select sno, 3, (select avg(score) from sc where cno = 2)<br>from student<br>where sno not in (select sno from sc where cno = 3)</p><h1 id="115、按平平均分从高到低显示所有学生的如下统计报表："><a href="#115、按平平均分从高到低显示所有学生的如下统计报表：" class="headerlink" title="115、按平平均分从高到低显示所有学生的如下统计报表："></a>115、按平平均分从高到低显示所有学生的如下统计报表：</h1><p>– 学号,企业管理,马克思,UML,数据库,物理,课程数,平均分<br>select sno as 学号<br>,max(case when cno = 1 then score end) AS 企业管理<br>,max(case when cno = 2 then score end) AS 马克思<br>,max(case when cno = 3 then score end) AS UML<br>,max(case when cno = 4 then score end) AS 数据库<br>,max(case when cno = 5 then score end) AS 物理<br>,count(cno) AS 课程数<br>,avg(score) AS 平均分<br>FROM sc<br>GROUP by sno<br>ORDER by avg(score) DESC</p><h1 id="116、查询各科成绩最高分和最低分："><a href="#116、查询各科成绩最高分和最低分：" class="headerlink" title="116、查询各科成绩最高分和最低分："></a>116、查询各科成绩最高分和最低分：</h1><p>以如下形式显示：课程号，最高分，最低分<br>select cno as 课程号, max(score) as 最高分, min(score) 最低分<br>from sc group by cno</p><p>select  course.cno as ‘课程号’<br>,MAX(score) as ‘最高分’<br>,MIN(score) as ‘最低分’<br>from sc,course<br>where sc.cno=course.cno<br>group by course.cno</p><h1 id="117、按各科平均成绩从低到高和及格率的百分数从高到低顺序"><a href="#117、按各科平均成绩从低到高和及格率的百分数从高到低顺序" class="headerlink" title="117、按各科平均成绩从低到高和及格率的百分数从高到低顺序"></a>117、按各科平均成绩从低到高和及格率的百分数从高到低顺序</h1><p>SELECT t.cno AS 课程号,<br>max(course.cname)AS 课程名,<br>isnull(AVG(score),0) AS 平均成绩,<br>100 * SUM(CASE WHEN isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/count(1) AS 及格率<br>FROM sc t, course<br>where t.cno = course.cno<br>GROUP BY t.cno<br>ORDER BY 及格率 desc</p><h1 id="118、查询如下课程平均成绩和及格率的百分数-用”1行”显示"><a href="#118、查询如下课程平均成绩和及格率的百分数-用”1行”显示" class="headerlink" title="118、查询如下课程平均成绩和及格率的百分数(用”1行”显示):"></a>118、查询如下课程平均成绩和及格率的百分数(用”1行”显示):</h1><p>企业管理（001），马克思（002），UML （003），数据库（004）<br>select<br>avg(case when cno = 1 then score end) as 平均分1,<br>avg(case when cno = 2 then score end) as 平均分2,<br>avg(case when cno = 3 then score end) as 平均分3,<br>avg(case when cno = 4 then score end) as 平均分4,<br>100 * sum(case when cno = 1 and score &gt; 60 then 1 else 0 end) / sum(casewhen cno = 1 then 1 else 0 end) as 及格率1,<br>100 * sum(case when cno = 2 and score &gt; 60 then 1 else 0 end) / sum(casewhen cno = 2 then 1 else 0 end) as 及格率2,<br>100 * sum(case when cno = 3 and score &gt; 60 then 1 else 0 end) / sum(casewhen cno = 3 then 1 else 0 end) as 及格率3,<br>100 * sum(case when cno = 4 and score &gt; 60 then 1 else 0 end) / sum(casewhen cno = 4 then 1 else 0 end) as 及格率4<br>from sc</p><h1 id="119、查询不同老师所教不同课程平均分-从高到低显示"><a href="#119、查询不同老师所教不同课程平均分-从高到低显示" class="headerlink" title="119、查询不同老师所教不同课程平均分, 从高到低显示"></a>119、查询不同老师所教不同课程平均分, 从高到低显示</h1><p>select max(c.tname) as 教师, max(b.cname) 课程, avg(a.score) 平均分<br>from sc a, course b, teacher c<br>where a.cno = b.cno and b.tno = c.tno<br>group by a.cno<br>order by 平均分 desc<br>或者：<br>select r.tname as ‘教师’,r.rname as ‘课程’ , AVG(score) as ‘平均分’<br>from sc,<br>(select  t.tname,c.cno as rcso,c.cname as rname<br>from teacher t ,course c<br>where t.tno=c.tno)r<br>where sc.cno=r.rcso<br>group by sc.cno,r.tname,r.rname<br>order by AVG(score) desc</p><h1 id="120、查询如下课程成绩均在第3名到第6名之间的学生的成绩："><a href="#120、查询如下课程成绩均在第3名到第6名之间的学生的成绩：" class="headerlink" title="120、查询如下课程成绩均在第3名到第6名之间的学生的成绩："></a>120、查询如下课程成绩均在第3名到第6名之间的学生的成绩：</h1><p>– [学生ID],[学生姓名],企业管理,马克思,UML,数据库,平均成绩<br>select top 6 max(a.sno) 学号, max(b.sname) 姓名,<br>max(case when cno = 1 then score end) as 企业管理,<br>max(case when cno = 2 then score end) as 马克思,<br>max(case when cno = 3 then score end) as UML,<br>max(case when cno = 4 then score end) as 数据库,<br>avg(score) as 平均分<br>from sc a, student b<br>where a.sno not in </p><p>(select top 2 sno from sc where cno = 1 order by score desc)<br>  and a.sno not in (select top 2 sno from sc where cno = 2 order by scoredesc)<br>  and a.sno not in (select top 2 sno from sc where cno = 3 order by scoredesc)<br>  and a.sno not in (select top 2 sno from sc where cno = 4 order by scoredesc)<br>  and a.sno = b.sno<br>group by a.sno</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一枚Java后端开发者，数据库知识必不可少，对数据库的掌握熟悉度的考察也是对这个人是否有扎实基本功的考察。特别对于初级开发者，面试可能不会去问框架相关知识，但是绝对不会不去考察数据库知识，这里收集一些常见类型的SQL语句，无论对于平常开发还是准备面试，都会有助益。&lt;/p
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips10 Java持久层</title>
    <link href="http://yoursite.com/2019/11/08/Tips10-Java%E6%8C%81%E4%B9%85%E5%B1%82/"/>
    <id>http://yoursite.com/2019/11/08/Tips10-Java持久层/</id>
    <published>2019-11-08T05:18:19.000Z</published>
    <updated>2019-11-08T07:53:57.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="91，什么是ORM？"><a href="#91，什么是ORM？" class="headerlink" title="91，什么是ORM？"></a>91，什么是ORM？</h1><p>  对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；</p><p>  简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p><h1 id="未学-92，Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"><a href="#未学-92，Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？" class="headerlink" title="(未学)92，Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"></a>(未学)92，Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？</h1><p>  SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。</p><p>  Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。</p><p>  Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。</p><h1 id="未学-93，Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？"><a href="#未学-93，Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？" class="headerlink" title="(未学)93，Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？"></a>(未学)93，Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</h1><p>  Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached）。</p><p>  瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；</p><p>  游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。</p><p>  save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。</p><p>  对于persist()方法，按照官方文档的说明：</p><p>  1、persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；</p><p>  2、persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；</p><p>  3、save()方法不保证第2条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</p><h1 id="未学-94，阐述Session加载实体对象的过程。"><a href="#未学-94，阐述Session加载实体对象的过程。" class="headerlink" title="(未学)94，阐述Session加载实体对象的过程。"></a>(未学)94，阐述Session加载实体对象的过程。</h1><p>  1、Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；<br>  2、如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；<br>  3、如果一级缓存查询失败查询二级缓存，如果二级缓存命中直接返回；<br>  4、如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；<br>  5、根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象；<br>  6、将对象纳入Session（一级缓存）的管理；<br>  7、如果有对应的拦截器，则执行拦截器的onLoad方法；<br>  8、如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；<br>  9、返回数据对象。</p><h1 id="95，MyBatis中使用-和-书写占位符有什么区别？"><a href="#95，MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="95，MyBatis中使用#和$书写占位符有什么区别？"></a>95，MyBatis中使用#和$书写占位符有什么区别？</h1><p>  “#”将传入的数据都当成一个字符串，会对传入的数据自动加上引号；</p><p>  “$”将传入的数据直接显示生成在SQL中。</p><p>  注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。</p><h1 id="96，解释一下MyBatis中命名空间（namespace）的作用。"><a href="#96，解释一下MyBatis中命名空间（namespace）的作用。" class="headerlink" title="96，解释一下MyBatis中命名空间（namespace）的作用。"></a>96，解释一下MyBatis中命名空间（namespace）的作用。</h1><p>  在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p><h1 id="97、MyBatis中的动态SQL是什么意思？"><a href="#97、MyBatis中的动态SQL是什么意思？" class="headerlink" title="97、MyBatis中的动态SQL是什么意思？"></a>97、MyBatis中的动态SQL是什么意思？</h1><p>   对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，如果不使用持久层框架我们可能需要自己拼装SQL语句，不过MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： </p><ul><li>if    - choose / when / otherwise    - trim    - where    - set     - foreach</li></ul><p>用法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;foo&quot; parameterType=&quot;Blog&quot; resultType=&quot;Blog&quot;&gt;        </span><br><span class="line">select * from t_blog where 1 = 1</span><br><span class="line">     &lt;if test=&quot;title != null&quot;&gt;            </span><br><span class="line">        and title = #&#123;title&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">     &lt;if test=&quot;content != null&quot;&gt;            </span><br><span class="line">        and content = #&#123;content&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">     &lt;if test=&quot;owner != null&quot;&gt;            </span><br><span class="line">        and owner = #&#123;owner&#125;</span><br><span class="line">     &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h1 id="98，JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#98，JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="98，JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>98，JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><p>   1、JDBC：数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p><p>   MyBatis：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</p><p>   2、JDBC：Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p>   MyBatis：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。<br>   3、JDBC：向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>   MyBatis： Mybatis自动将java对象映射至sql语句。<br>   4，JDBC：对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>   MyBatis：Mybatis自动将sql执行结果映射至java对象。</p><h1 id="99，MyBatis与Hibernate有哪些不同？"><a href="#99，MyBatis与Hibernate有哪些不同？" class="headerlink" title="99，MyBatis与Hibernate有哪些不同？"></a>99，MyBatis与Hibernate有哪些不同？</h1><p>   1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。<br>   2、Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。                3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。<br>   总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p><h1 id="100，简单的说一下MyBatis的一级缓存和二级缓存？"><a href="#100，简单的说一下MyBatis的一级缓存和二级缓存？" class="headerlink" title="100，简单的说一下MyBatis的一级缓存和二级缓存？"></a>100，简单的说一下MyBatis的一级缓存和二级缓存？</h1><p><a href="https://www.cnblogs.com/happyflyingpig/p/7739749.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyflyingpig/p/7739749.html</a><br>   Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象<br>   Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;91，什么是ORM？&quot;&gt;&lt;a href=&quot;#91，什么是ORM？&quot; class=&quot;headerlink&quot; title=&quot;91，什么是ORM？&quot;&gt;&lt;/a&gt;91，什么是ORM？&lt;/h1&gt;&lt;p&gt;  对象关系映射（Object-Relational Mapping，简称O
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>青山见我应如是</title>
    <link href="http://yoursite.com/2019/11/08/%E9%9D%92%E5%B1%B1%E8%A7%81%E6%88%91%E5%BA%94%E5%A6%82%E6%98%AF/"/>
    <id>http://yoursite.com/2019/11/08/青山见我应如是/</id>
    <published>2019-11-08T02:56:12.000Z</published>
    <updated>2019-11-08T02:57:26.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我见青山多妩媚"><a href="#我见青山多妩媚" class="headerlink" title="我见青山多妩媚"></a>我见青山多妩媚</h3><h3 id="青山见我应如是"><a href="#青山见我应如是" class="headerlink" title="青山见我应如是"></a>青山见我应如是</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我见青山多妩媚&quot;&gt;&lt;a href=&quot;#我见青山多妩媚&quot; class=&quot;headerlink&quot; title=&quot;我见青山多妩媚&quot;&gt;&lt;/a&gt;我见青山多妩媚&lt;/h3&gt;&lt;h3 id=&quot;青山见我应如是&quot;&gt;&lt;a href=&quot;#青山见我应如是&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="ty" scheme="http://yoursite.com/tags/ty/"/>
    
  </entry>
  
  <entry>
    <title>Tips9 框架</title>
    <link href="http://yoursite.com/2019/11/06/Tips9-%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/11/06/Tips9-框架/</id>
    <published>2019-11-06T09:01:13.000Z</published>
    <updated>2019-11-07T08:50:38.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="81，使用Spring框架的好处是什么？"><a href="#81，使用Spring框架的好处是什么？" class="headerlink" title="81，使用Spring框架的好处是什么？"></a>81，使用Spring框架的好处是什么？</h1><p>  轻量：Spring 是轻量的，基本的版本大约2MB。</p><p>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p><p>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p><p>  容器：Spring 包含并管理应用中对象的生命周期和配置。</p><p>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p><p>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p><p>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p><h1 id="82-Spring上下文-ApplicationContext通常的实现是什么"><a href="#82-Spring上下文-ApplicationContext通常的实现是什么" class="headerlink" title="82. Spring上下文,ApplicationContext通常的实现是什么?"></a>82. Spring上下文,ApplicationContext通常的实现是什么?</h1><p>   FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p>   ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p>   WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><ol><li>FileSystemXmlApplicationContext </li></ol><p>Java代码  </p><p>eg1.<br>pplicationContext ctx = new FileSystemXmlApplicationContext(“bean.xml”); //加载单个配置文件  </p><p>Java代码  </p><p>eg2.<br>String[] locations = {“bean1.xml”, “bean2.xml”, “bean3.xml”};<br>ApplicationContext ctx = new FileSystemXmlApplicationContext(locations ); //加载多个配置文件  </p><p>Java代码  </p><p>eg3.<br>ApplicationContext ctx =new FileSystemXmlApplicationContext(“D:roject/bean.xml”);//根据具体路径加载文件  </p><ol start="2"><li>ClassPathXmlApplicationContext </li></ol><p>Java代码  </p><p>eg1.<br>pplicationContext ctx = new ClassPathXmlApplicationContext(“bean.xml”);  </p><p>Java代码  </p><p> eg2.<br>String[] locations = {“bean1.xml”, “bean2.xml”, “bean3.xml”};<br>ApplicationContext ctx = new ClassPathXmlApplication(locations);<br>注：其中FileSystemXmlApplicationContext和ClassPathXmlApplicationContext与BeanFactory的xml文件定位方式一样是基于路径的。  </p><ol start="3"><li>XmlWebApplicationContext </li></ol><p>Java代码  </p><p>eg1.<br>ServletContext servletContext = request.getSession().getServletContext();<br>ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);  </p><h1 id="83，什么是Spring的依赖注入？有哪些方法进行依赖注入"><a href="#83，什么是Spring的依赖注入？有哪些方法进行依赖注入" class="headerlink" title="83，什么是Spring的依赖注入？有哪些方法进行依赖注入"></a>83，什么是Spring的依赖注入？有哪些方法进行依赖注入</h1><p>  依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><p>  构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p>  Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h1 id="84，什么是Spring-beans"><a href="#84，什么是Spring-beans" class="headerlink" title="84，什么是Spring beans?"></a>84，什么是Spring beans?</h1><p>   Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean> 的形式定义。</bean></p><p>   Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。</p><h1 id="85，解释Spring支持的几种bean的作用域。"><a href="#85，解释Spring支持的几种bean的作用域。" class="headerlink" title="85，解释Spring支持的几种bean的作用域。"></a>85，解释Spring支持的几种bean的作用域。</h1><p>   Spring框架支持以下五种bean的作用域：</p><p>   singleton : bean在每个Spring ioc 容器中只有一个实例。</p><p>   prototype：一个bean的定义可以有多个实例。</p><p>   request：每次http请求都会创建一个bean，该作用域仅在基于web的        Spring ApplicationContext情形下有效。</p><p>   session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p>   global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p>缺省的Spring bean 的作用域是Singleton.</p><h1 id="86，解释Spring框架中bean的生命周期。"><a href="#86，解释Spring框架中bean的生命周期。" class="headerlink" title="86，解释Spring框架中bean的生命周期。"></a>86，解释Spring框架中bean的生命周期。</h1><p>   <a href="https://www.cnblogs.com/javazhiyin/p/10905294.html" target="_blank" rel="noopener">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p><p>1.Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p><p>2.Bean实例化后对将Bean的引入和值注入到Bean的属性中</p><p>3.如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p><p>4.如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p><p>5.如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p><p>6.如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p><p>7.如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p><p>8.如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p><p>9.此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p><p>10.如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><h1 id="87，在-Spring中如何注入一个java集合？"><a href="#87，在-Spring中如何注入一个java集合？" class="headerlink" title="87，在 Spring中如何注入一个java集合？"></a>87，在 Spring中如何注入一个java集合？</h1><p><a href="https://www.cnblogs.com/shamo89/p/9916475.html" target="_blank" rel="noopener">https://www.cnblogs.com/shamo89/p/9916475.html</a><br>Spring提供以下几种集合的配置元素：</p><p>  <list>类型用于注入一列值，允许有相同的值。</list></p><p>  <set> 类型用于注入一组值，不允许有相同的值。</set></p><p>  <map> 类型用于注入一组键值对，键和值都可以为任意类型。</map></p><p>  <props>类型用于注入一组键值对，键和值都只能为String类型。</props></p><h1 id="88，解释不同方式的自动装配-。"><a href="#88，解释不同方式的自动装配-。" class="headerlink" title="88，解释不同方式的自动装配 。"></a>88，解释不同方式的自动装配 。</h1><p>有五种自动装配的方式，用来指导Spring容器用自动装配方式进行依赖注入。</p><p>   no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</p><p>   byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</p><p>   byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</p><p>   constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</p><p>   autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</p><h1 id="89，Spring框架的事务管理有哪些优点？"><a href="#89，Spring框架的事务管理有哪些优点？" class="headerlink" title="89，Spring框架的事务管理有哪些优点？"></a>89，Spring框架的事务管理有哪些优点？</h1><p><a href="https://blog.csdn.net/qq_19729259/article/details/88607452" target="_blank" rel="noopener">https://blog.csdn.net/qq_19729259/article/details/88607452</a><br>   它为不同的事务API  如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</p><p>   它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如</p><p>   它支持声明式事务管理。</p><p>   它和Spring各种数据访问抽象层很好得集成。</p><h1 id="90-什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#90-什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="90.什么是基于Java的Spring注解配置? 给一些注解的例子."></a>90.什么是基于Java的Spring注解配置? 给一些注解的例子.</h1><p>   基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>   以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;81，使用Spring框架的好处是什么？&quot;&gt;&lt;a href=&quot;#81，使用Spring框架的好处是什么？&quot; class=&quot;headerlink&quot; title=&quot;81，使用Spring框架的好处是什么？&quot;&gt;&lt;/a&gt;81，使用Spring框架的好处是什么？&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips8 JavaWeb</title>
    <link href="http://yoursite.com/2019/11/06/Tips8-JavaWeb/"/>
    <id>http://yoursite.com/2019/11/06/Tips8-JavaWeb/</id>
    <published>2019-11-06T04:06:30.000Z</published>
    <updated>2019-11-06T08:42:31.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="73，谈谈你对Spring的理解。"><a href="#73，谈谈你对Spring的理解。" class="headerlink" title="73，谈谈你对Spring的理解。"></a>73，谈谈你对Spring的理解。</h1><p>   1.Spring是实现了工厂模式的工厂类（在这里有必要解释清楚什么是工厂模式），这个类名为BeanFactory（实际上是一个接口），在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象的类名和实例对象的属性。</bean></p><ol start="2"><li><p>Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦，IOC也称为DI（Depency Injection）。</p></li><li><p>Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。</p><p>实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类。</p><p>在JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以Advice对象进行提供，显然要创建出代理对象，至少需要目标类和Advice类。spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;73，谈谈你对Spring的理解。&quot;&gt;&lt;a href=&quot;#73，谈谈你对Spring的理解。&quot; class=&quot;headerlink&quot; title=&quot;73，谈谈你对Spring的理解。&quot;&gt;&lt;/a&gt;73，谈谈你对Spring的理解。&lt;/h1&gt;&lt;p&gt;   1.Sprin
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips7 JavaWeb</title>
    <link href="http://yoursite.com/2019/11/05/Tips7-JavaWeb/"/>
    <id>http://yoursite.com/2019/11/05/Tips7-JavaWeb/</id>
    <published>2019-11-05T07:47:28.000Z</published>
    <updated>2019-11-12T06:10:54.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="61，JDBC访问数据库的基本步骤是什么？"><a href="#61，JDBC访问数据库的基本步骤是什么？" class="headerlink" title="61，JDBC访问数据库的基本步骤是什么？"></a>61，JDBC访问数据库的基本步骤是什么？</h1><p>1，加载驱动<br>2，通过DriverManager对象获取连接对象Connection<br>3，通过连接对象获取会话<br>4，通过会话进行数据的增删改查，封装对象<br>5，关闭资源</p><h1 id="62，说说preparedStatement和Statement的区别"><a href="#62，说说preparedStatement和Statement的区别" class="headerlink" title="62，说说preparedStatement和Statement的区别"></a>62，说说preparedStatement和Statement的区别</h1><p>1，效率：使用PreparedStatement执行SQL命令时,命令会被数据库编译和解析,并放到命令缓冲区.以后每当执行同一个PreparedStatement对象时,预编译的命令就可以重复使用<br>2，安全性：可以有效的避免sql注入攻击！sql注入攻击就是从客户端输入一些非法的特殊字符，而使服务器端在构造sql语句的时候仍然能够正确构造，从而收集程序和服务器的信息和数据。<br>比如：“select * from t_user where userName = ‘” + userName + “ ’ and password =’” + password + “’”<br>如果用户名和密码输入的是’1’ or ‘1’=’1’ ;  则生产的sql语句是：<br>“select * from t_user where userName = ‘1’ or ‘1’ =’1’  and password =’1’  or ‘1’=’1’  这个语句中的where 部分没有起到对数据筛选的作用。 </p><h1 id="63，说说事务的概念，在JDBC编程中处理事务的步骤。"><a href="#63，说说事务的概念，在JDBC编程中处理事务的步骤。" class="headerlink" title="63，说说事务的概念，在JDBC编程中处理事务的步骤。"></a>63，说说事务的概念，在JDBC编程中处理事务的步骤。</h1><p>1 事务是作为单个逻辑工作单元执行的一系列操作。<br>2，一个逻辑工作单元必须有四个属性，称为原子性、一致性、隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务<br>事务处理步骤：<br>3，conn.setAutoComit(false);设置提交方式为手工提交<br>4，conn.commit()提交事务<br>5，出现异常，回滚 conn.rollback();</p><h1 id="64，数据库连接池的原理。为什么要使用连接池。"><a href="#64，数据库连接池的原理。为什么要使用连接池。" class="headerlink" title="64，数据库连接池的原理。为什么要使用连接池。"></a>64，数据库连接池的原理。为什么要使用连接池。</h1><p>1，数据库连接是一件费时的操作，连接池可以使多个操作共享一个连接。<br>2，数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量、使用情况，为系统开发，测试及性能调整提供依据。<br>3，使用连接池是为了提高对数据库连接资源的管理</p><h1 id="65，JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？"><a href="#65，JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？" class="headerlink" title="65，JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？"></a>65，JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？</h1><p>　　当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。数据库的TRANSACTIONREADCOMMITTED，TRANSACTIONREPEATABLEREAD，和TRANSACTION_SERIALIZABLE隔离级别可以防止脏读。</p><h1 id="66，什么是幻读，哪种隔离级别可以防止幻读？"><a href="#66，什么是幻读，哪种隔离级别可以防止幻读？" class="headerlink" title="66，什么是幻读，哪种隔离级别可以防止幻读？"></a>66，什么是幻读，哪种隔离级别可以防止幻读？</h1><p>　　幻读是指一个事务多次执行一条查询返回的却是不同的值。假设一个事务正根据某个条件进行数据查询，然后另一个事务插入了一行满足这个查询条件的数据。之后这个事务再次执行了这条查询，返回的结果集中会包含刚插入的那条新数据。这行新数据被称为幻行，而这种现象就叫做幻读。</p><p>　　只有TRANSACTION_SERIALIZABLE隔离级别才能防止产生幻读。</p><h1 id="67，JDBC的DriverManager是用来做什么的？"><a href="#67，JDBC的DriverManager是用来做什么的？" class="headerlink" title="67，JDBC的DriverManager是用来做什么的？"></a>67，JDBC的DriverManager是用来做什么的？</h1><p>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面<br>然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p><h1 id="68，execute，executeQuery，executeUpdate的区别是什么？"><a href="#68，execute，executeQuery，executeUpdate的区别是什么？" class="headerlink" title="68，execute，executeQuery，executeUpdate的区别是什么？"></a>68，execute，executeQuery，executeUpdate的区别是什么？</h1><p>1，Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>2，Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。 ,<br>3，Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回，对于DDL语句，返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p><h1 id="69，SQL查询出来的结果分页展示一般怎么做？"><a href="#69，SQL查询出来的结果分页展示一般怎么做？" class="headerlink" title="69，SQL查询出来的结果分页展示一般怎么做？"></a>69，SQL查询出来的结果分页展示一般怎么做？</h1><p>Oracle：</p><p>select * from<br>(select  student.<em>,rownum as tempid from student )  t<br>where t.tempid between ” + pageSize</em>(pageNumber-1) + ” and ” + pageSize*pageNumber。</p><p>MySQL：<br>   select * from students limit ” + pageSize*(pageNumber-1) + “,” + pageSize;</p><p>sql server:<br>   select top ” + pageSize + ” * from students where id not in +<br>(select top ” + pageSize * (pageNumber-1) +  id from students order by id) +<br>“order by id;</p><h1 id="70，JDBC的ResultSet是什么？"><a href="#70，JDBC的ResultSet是什么？" class="headerlink" title="70，JDBC的ResultSet是什么？"></a>70，JDBC的ResultSet是什么？</h1><p>在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。<br>ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。<br>默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet</p><p>当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。<br>可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;61，JDBC访问数据库的基本步骤是什么？&quot;&gt;&lt;a href=&quot;#61，JDBC访问数据库的基本步骤是什么？&quot; class=&quot;headerlink&quot; title=&quot;61，JDBC访问数据库的基本步骤是什么？&quot;&gt;&lt;/a&gt;61，JDBC访问数据库的基本步骤是什么？&lt;/
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips6 JavaWeb</title>
    <link href="http://yoursite.com/2019/11/01/Tips6-JavaWeb/"/>
    <id>http://yoursite.com/2019/11/01/Tips6-JavaWeb/</id>
    <published>2019-11-01T06:37:30.000Z</published>
    <updated>2019-11-01T07:24:43.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="51、说一说Servlet的生命周期"><a href="#51、说一说Servlet的生命周期" class="headerlink" title="51、说一说Servlet的生命周期?"></a>51、说一说Servlet的生命周期?</h1><p>   Servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init(),service()和destroy方法表达。</p><p>   Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</p><p>web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。</p><h1 id="52、Servlet-API中forward-与redirect-的区别？"><a href="#52、Servlet-API中forward-与redirect-的区别？" class="headerlink" title="52、Servlet API中forward()与redirect()的区别？"></a>52、Servlet API中forward()与redirect()的区别？</h1><p>三、本质区别</p><p>转发是服务器行为，重定向是客户端行为。为什么这样说呢，这就要看两个动作的工作流程： </p><p>转发过程：客户浏览器发送http请求—&gt;web服务器接受此请求—&gt;调用内部的一个方法在容器内部完成请求处理和转发动作—&gt;将目标资源 发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客 户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。 </p><p>重定向过程：客户浏览器发送http请求—&gt;web服务器接受后发送302状态码响应及对应新的location给客户浏览器—&gt;客户浏览器发现 是302响应，则自动再发送一个新的http请求，请求url是新的location地址—&gt;服务器根据此请求寻找资源并发送给客户。在这里 location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的 路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。 </p><p>重定向，其实是两次request:第一次，客户端request A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。 </p><p>  1.从地址栏显示来说<br>   forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>   redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.所以redirect等于客户端向服务器端发出两次request，同时也接受两次response。<br>  2.从数据共享来说<br>   forward:转发页面和转发到的页面可以共享request里面的数据.<br>   redirect:不能共享数据.<br>   redirect不仅可以重定向到当前应用程序的其他资源,还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源.<br>   forward方法只能在同一个Web应用程序内的资源之间转发请求.forward 是服务器内部的一种操作.<br>   redirect 是服务器通知客户端,让客户端重新发起请求.<br>   所以,你可以说 redirect 是一种间接的请求, 但是你不能说”一个请求是属于forward还是redirect “<br>  3.从运用地方来说<br>   forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>   redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>  4.从效率来说<br>   forward:高.<br>   redirect:低.</p><h1 id="53、request-getAttribute-和-request-getParameter-有何区别"><a href="#53、request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="53、request.getAttribute()和 request.getParameter()有何区别?"></a>53、request.getAttribute()和 request.getParameter()有何区别?</h1><p>   1，request.getParameter()取得是通过容器的实现来取得通过类似post，get等方式传入的数据。</p><p>   request.setAttribute()和getAttribute()只是在web容器内部流转，仅仅是请求处理阶段。</p><p>   2，getAttribute是返回对象,getParameter返回字符串</p><p>   3，getAttribute()一向是和setAttribute()一起使用的，只有先用setAttribute()设置之后，才能够通过getAttribute()来获得值，它们传递的是Object类型的数据。而且必须在同一个request对象中使用才有效。,而getParameter()是接收表单的get或者post提交过来的参数</p><h1 id="54，jsp静态包含和动态包含的区别"><a href="#54，jsp静态包含和动态包含的区别" class="headerlink" title="54，jsp静态包含和动态包含的区别"></a>54，jsp静态包含和动态包含的区别</h1><p>   1、&lt;%@include file=”xxx.jsp”%&gt;为jsp中的编译指令，其文件的包含是发生在jsp向servlet转换的时期，而&lt;jsp:include page=”xxx.jsp”&gt;是jsp中的动作指令，其文件的包含是发生在编译时期，也就是将java文件编译为class文件的时期 </p><p>   2、使用静态包含只会产生一个class文件，而使用动态包含会产生多个class文件 </p><p>   3、使用静态包含，包含页面和被包含页面的request对象为同一对象，因为静态包含只是将被包含的页面的内容复制到包含的页面中去；而动态包含包含页面和被包含页面不是同一个页面，被包含的页面的request对象可以取到的参数范围要相对大些，不仅可以取到传递到包含页面的参数，同样也能取得在包含页面向下传递的参数 </p><h1 id="55，MVC的各个部分都有那些技术来实现-如何实现"><a href="#55，MVC的各个部分都有那些技术来实现-如何实现" class="headerlink" title="55，MVC的各个部分都有那些技术来实现?如何实现?"></a>55，MVC的各个部分都有那些技术来实现?如何实现?</h1><p>   MVC是Model－View－Controller的简写。Model代表的是应用的业务逻辑（通过JavaBean，EJB组件实现），View是应用的表示面（由JSP页面产生），Controller是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</p><h1 id="56，jsp有哪些内置对象-作用分别是什么"><a href="#56，jsp有哪些内置对象-作用分别是什么" class="headerlink" title="56，jsp有哪些内置对象?作用分别是什么?"></a>56，jsp有哪些内置对象?作用分别是什么?</h1><p>   JSP共有以下9个内置的对象：</p><p>   1，request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>   2，response 网页传回用户端的回应</p><p>   3，pageContext 网页的属性是在这里管理</p><p>   4，session 与请求有关的会话期</p><p>   5，application servlet 正在执行的内容</p><p>   6，out 用来传送回应的输出</p><p>   7，config  servlet的构架部件</p><p>   8，page JSP网页本身</p><p>   9，exception 针对错误网页，未捕捉的例外</p><h1 id="57，Http中，get和post方法的区别"><a href="#57，Http中，get和post方法的区别" class="headerlink" title="57，Http中，get和post方法的区别"></a>57，Http中，get和post方法的区别</h1><p>   1，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求</p><p>   2，Get是获取信息，而不是修改信息，类似数据库查询功能一样，数据不会被修改</p><p>   3，Get请求的参数会跟在url后进行传递，请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连,％XX中的XX为该符号以16进制表示的ASCII，如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。</p><p>   4，Get传输的数据有大小限制，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，不同的浏览器对URL的长度的限制是不同的。</p><p>   5，GET请求的数据会被浏览器缓存起来，用户名和密码将明文出现在URL上，其他人可以查到历史浏览记录，数据不太安全。</p><p>   在服务器端，用Request.QueryString来获取Get方式提交来的数据<br>   Post请求则作为http消息的实际内容发送给web服务器，数据放置在HTML Header内提交，Post没有限制提交的数据。Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址，对于敏感数据和不是中文字符的数据，则用post。</p><p>   6，POST表示可能修改变服务器上的资源的请求，在服务器端，用Post方式提交的数据只能用Request.Form来获取。</p><h1 id="58，什么是cookie？Session和cookie有什么区别？"><a href="#58，什么是cookie？Session和cookie有什么区别？" class="headerlink" title="58，什么是cookie？Session和cookie有什么区别？"></a>58，什么是cookie？Session和cookie有什么区别？</h1><p>   Cookie是会话技术,将用户的信息保存到浏览器的对象.</p><p>   区别：</p><p>   (1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>   (2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>   (3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>   (4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。</p><p>   结论：</p><p>   将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中。</p><h1 id="59，jsp和servlet的区别、共同点、各自应用的范围？"><a href="#59，jsp和servlet的区别、共同点、各自应用的范围？" class="headerlink" title="59，jsp和servlet的区别、共同点、各自应用的范围？"></a>59，jsp和servlet的区别、共同点、各自应用的范围？</h1><p>   JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。</p><p>   Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。</p><p>   JSP侧重于视图，Servlet主要用于控制逻辑。在struts框架中,JSP位于MVC设计模式的视图层,而Servlet位于控制层.</p><h1 id="60，tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#60，tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="60，tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>60，tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><p>   当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）</p><p>   在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;51、说一说Servlet的生命周期&quot;&gt;&lt;a href=&quot;#51、说一说Servlet的生命周期&quot; class=&quot;headerlink&quot; title=&quot;51、说一说Servlet的生命周期?&quot;&gt;&lt;/a&gt;51、说一说Servlet的生命周期?&lt;/h1&gt;&lt;p&gt;   S
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips5 基础</title>
    <link href="http://yoursite.com/2019/10/31/Tips5-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/31/Tips5-基础/</id>
    <published>2019-10-31T09:45:45.000Z</published>
    <updated>2019-11-01T06:22:29.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="41、a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#41、a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="41、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？"></a>41、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</h1><p>   hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><h1 id="42、字节流与字符流的区别、"><a href="#42、字节流与字符流的区别、" class="headerlink" title="42、字节流与字符流的区别、"></a>42、字节流与字符流的区别、</h1><p>   实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件</p><p>   要把一段二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p><p>   计算机中的一切最终都是二进制的字节形式存在。对于经常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，Java专门提供了字符流包装类。</p><p>   底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p><p>   字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p><h1 id="43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"><a href="#43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。" class="headerlink" title="43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"></a>43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</h1><p>   我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输。</p><p>   但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现方法，implements Serializable只是为了标注该对象是可被序列化的。</p><p>   例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现Serializable接口。</p><h1 id="44、描述一下JVM加载class文件的原理机制"><a href="#44、描述一下JVM加载class文件的原理机制" class="headerlink" title="44、描述一下JVM加载class文件的原理机制?"></a>44、描述一下JVM加载class文件的原理机制?</h1><p>   JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤<br>   <img src="https://img-blog.csdn.net/20170819200711962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Vpc2c4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>   1) 装载：查找并加载类的二进制数据；<br>   2)链接：<br>   验证：确保被加载类的正确性；<br>   准备：为类的静态变量分配内存，并将其初始化为默认值；<br>   解析：把类中的符号引用转换为直接引用；<br>   3)初始化：为类的静态变量赋予正确的初始值；</p><p>   JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><h1 id="45、heap和stack有什么区别。"><a href="#45、heap和stack有什么区别。" class="headerlink" title="45、heap和stack有什么区别。"></a>45、heap和stack有什么区别。</h1><p>   各司其职<br>   最主要的区别就是栈内存用来存储局部变量和方法调用。<br>   而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p><p>   独有还是共享<br>   栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br>   而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p><p>   异常错误<br>   如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br>   而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p><p>   空间大小<br>   栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。</p><h1 id="46、GC是什么-为什么要有GC"><a href="#46、GC是什么-为什么要有GC" class="headerlink" title="46、GC是什么?为什么要有GC?"></a>46、GC是什么?为什么要有GC?</h1><p>   GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><h1 id="47、垃圾回收的优点和原理。并考虑2种回收机制。"><a href="#47、垃圾回收的优点和原理。并考虑2种回收机制。" class="headerlink" title="47、垃圾回收的优点和原理。并考虑2种回收机制。"></a>47、垃圾回收的优点和原理。并考虑2种回收机制。</h1><p>   Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。</p><p>   垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p><p>   回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p><h1 id="48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h1><p>   对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>   程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h1 id="49、Java-中，throw-和-throws-有什么区别"><a href="#49、Java-中，throw-和-throws-有什么区别" class="headerlink" title="49、Java 中，throw 和 throws 有什么区别"></a>49、Java 中，throw 和 throws 有什么区别</h1><p>   throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个Exception，如：<br>throw new IllegalArgumentException(“XXXXXXXXX″)</p><p>   而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p><h1 id="50，java中会存在内存泄漏吗，请简单描述。"><a href="#50，java中会存在内存泄漏吗，请简单描述。" class="headerlink" title="50，java中会存在内存泄漏吗，请简单描述。"></a>50，java中会存在内存泄漏吗，请简单描述。</h1><p>   内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的</p><p>   java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。</p><p>   1.如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p><p>   2.当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;41、a-hashCode-有什么用？与-a-equals-b-有什么关系？&quot;&gt;&lt;a href=&quot;#41、a-hashCode-有什么用？与-a-equals-b-有什么关系？&quot; class=&quot;headerlink&quot; title=&quot;41、a.hashCode() 
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tips1 基础</title>
    <link href="http://yoursite.com/2019/10/31/Tips1-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/31/Tips1-基础/</id>
    <published>2019-10-31T02:20:38.000Z</published>
    <updated>2019-10-31T02:20:38.865Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8 组合设计模式</title>
    <link href="http://yoursite.com/2019/10/16/8-%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/16/8-组合设计模式/</id>
    <published>2019-10-16T09:31:30.000Z</published>
    <updated>2019-10-16T09:31:30.941Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>7 装饰者设计模式</title>
    <link href="http://yoursite.com/2019/10/14/7-%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/14/7-装饰者设计模式/</id>
    <published>2019-10-14T08:24:23.000Z</published>
    <updated>2019-10-15T09:44:17.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式介绍"><a href="#装饰者模式介绍" class="headerlink" title="装饰者模式介绍"></a>装饰者模式介绍</h1><p>装饰者模式就像打包一个快递<br>主体比如：陶瓷、衣服 (Component) // 被装饰者<br>包装 ：比如：报纸填充、塑料泡沫、纸板、木板 (<br>2)Component主体：比如类似前面的 Drink</p><p>3)ConcreteComponent 和 Decorator<br>ConcreteComponent ：具体的主体比如前面的各个单品咖啡<br>Decorator: 装饰者，比如各调料</p><p>4)在如图的 Component 与 ConcreteComponent 之间 ，如果<br>ConcreteComponent 类很多 还可以设计一个缓冲层，将共有的部分提取出来，<br>抽象层一个类 。<br><img src="https://upload-images.jianshu.io/upload_images/18958678-cd96308bd2f499a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/18958678-aff98dc0b4a3b6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public abstract class Drink &#123;</span><br><span class="line">    public String des;  //描述</span><br><span class="line">    private float price = 0.0f;</span><br><span class="line"></span><br><span class="line">    //计算费用的抽象方法，由子类实现</span><br><span class="line">    public abstract float cost();</span><br><span class="line"></span><br><span class="line">    public void setDes(String des) &#123;</span><br><span class="line">        this.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(float price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Coffee extends Drink &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        return super.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class ACoffee extends Coffee &#123;</span><br><span class="line">    public ACoffee() &#123;</span><br><span class="line">        setDes(&quot;A咖啡&quot;);</span><br><span class="line">        setPrice(6.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class BCoffee extends Coffee &#123;</span><br><span class="line">    public BCoffee() &#123;</span><br><span class="line">        setDes(&quot;B咖啡&quot;);</span><br><span class="line">        setPrice(7.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Decorator extends Drink &#123;</span><br><span class="line"></span><br><span class="line">    private Drink obj;</span><br><span class="line"></span><br><span class="line">    public Decorator(Drink obj) &#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        //getPrice 自己价格</span><br><span class="line">        return getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return des + &quot; &quot; + getPrice() + &quot; &amp;&amp; &quot; + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Chocolate extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public Chocolate(Drink obj) &#123;</span><br><span class="line">        super(obj);</span><br><span class="line">        setDes(&quot;巧克力&quot;);</span><br><span class="line">        setPrice(3.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Milk extends Decorator &#123;</span><br><span class="line">    public Milk(Drink obj) &#123;</span><br><span class="line">        super(obj);</span><br><span class="line">        setDes(&quot;牛奶&quot;);</span><br><span class="line">        setPrice(2.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package decorator;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //先点一份ACoffee</span><br><span class="line">        Drink order = new ACoffee();</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line"></span><br><span class="line">        //加入一份牛奶</span><br><span class="line">        order = new Milk(order);</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line"></span><br><span class="line">        //在加入一份巧克力</span><br><span class="line">        order = new Chocolate(order);</span><br><span class="line">        System.out.println(order.cost());</span><br><span class="line">        System.out.println(order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">6.0</span><br><span class="line">A咖啡</span><br><span class="line">8.0</span><br><span class="line">牛奶 2.0 &amp;&amp; A咖啡</span><br><span class="line">11.0</span><br><span class="line">巧克力 3.0 &amp;&amp; 牛奶 2.0 &amp;&amp; A咖啡</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><img src="https://upload-images.jianshu.io/upload_images/18958678-ad874d8596feaf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/18958678-ee87dabb1f7063d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者模式介绍&quot;&gt;&lt;a href=&quot;#装饰者模式介绍&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式介绍&quot;&gt;&lt;/a&gt;装饰者模式介绍&lt;/h1&gt;&lt;p&gt;装饰者模式就像打包一个快递&lt;br&gt;主体比如：陶瓷、衣服 (Component) // 被装饰者&lt;br
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>6 桥接设计模式</title>
    <link href="http://yoursite.com/2019/10/13/6-%E6%A1%A5%E6%8E%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/13/6-桥接设计模式/</id>
    <published>2019-10-13T07:14:11.000Z</published>
    <updated>2019-10-14T08:23:58.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桥接模式-Bridge-基本介绍"><a href="#桥接模式-Bridge-基本介绍" class="headerlink" title="桥接模式 Bridge 基本介绍"></a>桥接模式 Bridge 基本介绍</h1><p>基本介绍<br>1)桥接模式 (Bridge模式是指 ：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。<br>2)是一种结构型设计模式<br>3)Bridge 模式基于类的最小设计原则 ，通过使用封装、聚合及继承等行为让不同<br>的类承担不同的职责。它的主要特点是把抽象 (与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展<br><img src="https://upload-images.jianshu.io/upload_images/18958678-654d4d41369f2ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">//接口</span><br><span class="line">public interface Brand &#123;</span><br><span class="line">    void open();</span><br><span class="line">    void close();</span><br><span class="line">    void call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class XiaoMi implements Brand&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;小米开机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;小米关机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;小米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class Vivo implements Brand&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo开机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo关机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;Vivo打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public abstract class Phone &#123;</span><br><span class="line"></span><br><span class="line">    //聚合品牌</span><br><span class="line">    private Brand brand;</span><br><span class="line"></span><br><span class="line">    public Phone(Brand brand)&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void open()&#123;</span><br><span class="line">        brand.open();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void close()&#123;</span><br><span class="line">        brand.close();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void call()&#123;</span><br><span class="line">        brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class APhone extends Phone &#123;</span><br><span class="line">    public APhone(Brand brand) &#123;</span><br><span class="line">        super(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void open()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;A手机打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        super.close();</span><br><span class="line">        System.out.println(&quot;A手机关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void call()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;A手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class BPhone extends Phone &#123;</span><br><span class="line">    public BPhone(Brand brand) &#123;</span><br><span class="line">        super(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void open()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;B手机打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        super.close();</span><br><span class="line">        System.out.println(&quot;B手机关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void call()&#123;</span><br><span class="line">        super.open();</span><br><span class="line">        System.out.println(&quot;B手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package bridge;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone1 = new APhone(new XiaoMi());</span><br><span class="line">        phone1.call();</span><br><span class="line">        phone1.close();</span><br><span class="line">        phone1.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>桥接模式在JDBC中的应用<br><img src="https://upload-images.jianshu.io/upload_images/18958678-2c4fadc229e6ca8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桥接模式-Bridge-基本介绍&quot;&gt;&lt;a href=&quot;#桥接模式-Bridge-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;桥接模式 Bridge 基本介绍&quot;&gt;&lt;/a&gt;桥接模式 Bridge 基本介绍&lt;/h1&gt;&lt;p&gt;基本介绍&lt;br&gt;1)桥接模式
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>5 适配器设计模式</title>
    <link href="http://yoursite.com/2019/10/11/5-%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/11/5-适配器设计模式/</id>
    <published>2019-10-11T03:18:05.000Z</published>
    <updated>2019-10-13T06:56:36.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器<br>2)适配器 模式属于结构型模式<br>3)主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被适配的类</span><br><span class="line"> */</span><br><span class="line">public class Voltage220V &#123;</span><br><span class="line">    public int output220V()&#123;</span><br><span class="line">        //输出220V电压</span><br><span class="line">        int src = 220;</span><br><span class="line">        System.out.println(&quot;电压=&quot; + src + &quot;伏特&quot;);</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配接口</span><br><span class="line"> */</span><br><span class="line">public interface IVoltage5V &#123;</span><br><span class="line">    public int output5V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter extends Voltage220V implements IVoltage5V&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    //充电</span><br><span class="line">    public void charging(IVoltage5V iVoltage5V)&#123;</span><br><span class="line">        if (iVoltage5V.output5V() == 5) &#123;</span><br><span class="line">            System.out.println(&quot;电压为5V，正在充电&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;电压出错，无法充电&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类适配器模式注意事项和细节<br>1)Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点因为这要求dst必须是接口，有一定局限性.<br>2)src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本 。<br>3)由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得Adapter的灵活性增强了</p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>1)基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承src 类，而是持有 src 类的实例，以解决兼容性的问题。 即持有 src 类，实现 dst 类接口，完成src–&gt;dst 的适配<br>2)根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。<br>3)对象适配器模式是适配器模式常用的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter implements IVoltage5V&#123;</span><br><span class="line">    </span><br><span class="line">    private Voltage220V voltage220V;</span><br><span class="line">    </span><br><span class="line">    //不再集成，而是通过关联关系中的聚合</span><br><span class="line">    //即利用构造方法传入一个Voltage220V的实例</span><br><span class="line">    public VoltageAdapter(Voltage220V voltage220V) &#123;</span><br><span class="line">        this.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = voltage220V.output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter(new Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><p>1)一些书籍称为：适配器模式 (Default Adapter或缺省适配器模式<br>2)当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需 求<br>3)适用于一个接口不想使用其所有的方法的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface4 &#123;</span><br><span class="line">    public void m1();</span><br><span class="line">    public void m2();</span><br><span class="line">    public void m3();</span><br><span class="line">    public void m4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在抽象类中空实现所有方法</span><br><span class="line">public abstract class AbsAdapter implements Interface4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void m1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbsAdapter adapter = new AbsAdapter() &#123;</span><br><span class="line">            //只需覆盖我们需要使用的接口方法</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void m1() &#123;</span><br><span class="line">                System.out.println(&quot;使用了m1方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        adapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>适配器模式在SpringMVC框架应用<br><img src="https://upload-images.jianshu.io/upload_images/18958678-ed3140e11d339369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/18958678-a0cd9b8752ee4232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="适配器模式的注意事项和细节"><a href="#适配器模式的注意事项和细节" class="headerlink" title="适配器模式的注意事项和细节"></a>适配器模式的注意事项和细节</h1><p>1)三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来<br>命名的。<br>2)类适配器：以类给到，在 Adapter里，就是将 src 当做类，继承对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持 有接口适配 器：以 接口给到，在 Adapter 里，将 src 作为一个接口实现<br>3)Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>4 建造者设计模式</title>
    <link href="http://yoursite.com/2019/10/10/4-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/10/4-建造者设计模式/</id>
    <published>2019-10-10T07:21:12.000Z</published>
    <updated>2019-10-11T03:18:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1.适用场景：<br>1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果<br>2)多个部件都可以装配到一个对象中，但产生的运行结果不相同<br>3)产品类非常复杂或者产品类因为调用顺序不同而产生不同作用<br>4)初始化一个对象时，参数过多，或者很多参数具有默认值<br>5)Builder模式不适合创建差异性很大的产品类<br>6)产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本<br>7)需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</p><p>2.建造者模式的四个角色<br>1)Product （产品角色一个具体的产品对象 。<br>2)Builder （抽象建造者 创建一个Product对象的各个部件指定的接口抽象类 。<br>3)ConcreteBuilder （具体建造者实现接口，构建和装配各个部件 。<br>4)Director （指挥者 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。<br><img src="https://upload-images.jianshu.io/upload_images/18958678-732af724ba70d047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="具体对象"><a href="#具体对象" class="headerlink" title="具体对象"></a>具体对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">    private String baise;</span><br><span class="line">    private String wall;</span><br><span class="line">    private String roofed;</span><br><span class="line">//getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象的建造者</span><br><span class="line"> */</span><br><span class="line">public abstract class HouseBuilder &#123;</span><br><span class="line">    protected House house = new House();</span><br><span class="line"></span><br><span class="line">    //建造的抽象流程</span><br><span class="line">    public abstract void buildBasic();</span><br><span class="line">    public abstract void buildWalls();</span><br><span class="line">    public abstract void roofed();</span><br><span class="line"></span><br><span class="line">    //造好房子，将房子返回</span><br><span class="line">    public House buildHouse()&#123;</span><br><span class="line">        return house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CommonHouse extends HouseBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildBasic() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子打地基5米&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildWalls() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子建墙四堵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void roofed() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子造天花板&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指挥者</span><br><span class="line"> */</span><br><span class="line">public class HouseDirector &#123;</span><br><span class="line"></span><br><span class="line">    HouseBuilder houseBuilder = null;</span><br><span class="line"></span><br><span class="line">    //构造器传入houseBuilder</span><br><span class="line">    public HouseDirector(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过setter传入houseBuilder</span><br><span class="line">    public void setHouseBuilder(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指挥者指挥建造的房子的流程</span><br><span class="line">    public House constructHouse()&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        return houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //盖普通房子</span><br><span class="line">        CommonHouse commonHouse = new CommonHouse();</span><br><span class="line">        //准备指挥者</span><br><span class="line">        HouseDirector houseDirector = new HouseDirector(commonHouse);</span><br><span class="line">        //完成</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>建造者设计模式在JDK中java.lang.StringBuilder中的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client.java</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(&quot;sss&quot;);</span><br><span class="line"></span><br><span class="line">StringBuilder.java</span><br><span class="line">public final class StringBuilder</span><br><span class="line">extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder.java</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br></pre></td></tr></table></figure><p>1.Appendable接口定义了多个append抽象方法，所以Appendable为抽象建造者，定义了抽象方法；<br>2.AbstractStringBuilder实现了Appendable方法，所以AbstractStringBuilder是建造者，只是不能实例化<br>3.StringBuilder既是指挥者，又是具体的建造者，比如建造方法的实现是由 AbstractStringBuilder 完成 , 而 StringBuilder 继承了<br>AbstractStringBuilder。</p><p>4.建造者模式与抽象工厂模式的比较:<br>1)与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。<br>2)在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。<br>3)如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1.适用场景：&lt;br&gt;1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果&lt;br&gt;2)多个部件都可以装配
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3 原型模式</title>
    <link href="http://yoursite.com/2019/10/09/3-%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/09/3-原型设计模式/</id>
    <published>2019-10-09T06:58:29.000Z</published>
    <updated>2019-10-10T08:25:52.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>2)原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象无需知道如何创建的细节<br>3)工作原理是 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone。<br>4)二者只是属性相同，并不是同一个<br>5)对象.clone是浅拷贝<br>6)深克隆两种方法：1.重写clone方法。2.通过对象的序列化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Sheep implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sheep = (Sheep) super.clone();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return sheep;</span><br><span class="line">    &#125;</span><br><span class="line">//......</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = new Sheep(&quot;Tom&quot;, 1, &quot;White&quot;);</span><br><span class="line">        Sheep cloned1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned3 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned4 = (Sheep) sheep.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(cloned1);</span><br><span class="line">        System.out.println(cloned2);</span><br><span class="line">        System.out.println(cloned3);</span><br><span class="line">        System.out.println(cloned4);</span><br><span class="line">        System.out.println(cloned1==cloned2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h2><p>1)Spring 中原 型 bean 的创建，就是原型模式的应用,核心代码在doGetBean中对mdb.isSingleton()或者mdb.isPrototype之后，获取原型。<br>2)代码分析 +Debug 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beans.xml</span><br><span class="line">&lt;bean id= id=&quot;id01&quot; class=&quot;com.atguigu.spring.bean.Monster&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line">ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">//获取 monster[ 通过 id 获取 monster]</span><br><span class="line">Object bean = applicationContext.getBean(&quot;id01&quot;);</span><br><span class="line">System.out.println(&quot;bean&quot; + bean);</span><br></pre></td></tr></table></figure><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>数据类型分为两种基础类型和引用类型：<br>1、基础类型：像Number、String、Boolean等这种为基本类型<br>2、引用类型：Object和Array<br>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class Sheep implements Cloneable implements Serializable, Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line">    public DeepCloneableTarget deepCloneableTarget;</span><br><span class="line"></span><br><span class="line">    //方式一：重写clone方法</span><br><span class="line">    //1.基本类型，直接super处理，不用单独处理</span><br><span class="line">    //2.引用类型，对此直接调用该引用对象自身的clone方法</span><br><span class="line">    //这种方法真的要写需要递归，分支较大，复杂度不可预知，不推荐</span><br><span class="line"></span><br><span class="line">    //方式二：利用对象的序列化实现</span><br><span class="line">    public Object deepClone() &#123;</span><br><span class="line"></span><br><span class="line">        //创建流对象</span><br><span class="line">        ByteArrayOutputStream bos = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        ByteArrayInputStream bis = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            //序列化</span><br><span class="line">            bos = new ByteArrayOutputStream();</span><br><span class="line">            oos = new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this); //当前这个对象以对象流的方式输出</span><br><span class="line"></span><br><span class="line">            //反序列化</span><br><span class="line">            bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = new ObjectInputStream(bis);</span><br><span class="line">            Object copyObj = ois.readObject();</span><br><span class="line"></span><br><span class="line">            return copyObj;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭流</span><br><span class="line">            try &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;br&gt;2)原型
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
