<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-25T07:51:03.695Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>codingNow 16 判断二叉树的包含问题</title>
    <link href="http://yoursite.com/2019/08/25/codingNow-17-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/25/codingNow-17-判断二叉树的包含问题/</id>
    <published>2019-08-25T07:43:42.000Z</published>
    <updated>2019-08-25T07:51:03.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root2.val==root1.val)&#123;</span><br><span class="line">                    result = match(root1, root2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    result = HasSubtree(root1.left, root2) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    result = HasSubtree(root1.right, root2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1.val != node2.val) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">        <span class="keyword">return</span> match(node1.left,node2.left) &amp;&amp; match(node1.right,node2.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 16 链表按顺序合并</title>
    <link href="http://yoursite.com/2019/08/25/codingNow-16-%E9%93%BE%E8%A1%A8%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%90%88%E5%B9%B6/"/>
    <id>http://yoursite.com/2019/08/25/codingNow-16-链表按顺序合并/</id>
    <published>2019-08-25T06:15:31.000Z</published>
    <updated>2019-08-25T06:16:22.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 15 反转链表</title>
    <link href="http://yoursite.com/2019/08/25/codingNow-15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/25/codingNow-15-反转链表/</id>
    <published>2019-08-25T05:13:11.000Z</published>
    <updated>2019-08-25T05:25:40.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，反转链表后，输出新链表的表头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line"></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>一次遍历，连续三个位置pre，head，next<br>pre和head用来完成.next关系的重构，以及后序将head赋给pre，完成前移操作。<br>next用来存储当前节点head的下一个节点，不然在上一步关系重构后会丢失原有的下一个节点信息，事先存储之后再赋值给head，完成前移操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 14 输出链表中倒数第k个元素</title>
    <link href="http://yoursite.com/2019/08/25/codingNow-14-%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/08/25/codingNow-14-输出链表中倒数第k个元素/</id>
    <published>2019-08-25T03:48:11.000Z</published>
    <updated>2019-08-25T03:53:03.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="1-双指针（两者相差k-1）"><a href="#1-双指针（两者相差k-1）" class="headerlink" title="1.双指针（两者相差k-1）"></a>1.双指针（两者相差k-1）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p, q;</span><br><span class="line">        p = q = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &lt; k ? <span class="keyword">null</span> : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-堆栈"><a href="#1-堆栈" class="headerlink" title="1.堆栈"></a>1.堆栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || head == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>堆栈方法十分直观，但消耗了额外空间。<br>双指针先让pre走k-1步，再一起走，直到pre到末位结束，此时p指向倒数第k个。<br>注意点：判断，自增，执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;h2 id=&quot;1-双指针（两者相差k-1）&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 13 数组按奇偶进行原序归类</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-13-%E6%95%B0%E7%BB%84%E6%8C%89%E5%A5%87%E5%81%B6%E8%BF%9B%E8%A1%8C%E5%8E%9F%E5%BA%8F%E5%BD%92%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-13-数组按奇偶进行原序归类/</id>
    <published>2019-08-24T13:03:10.000Z</published>
    <updated>2019-08-24T13:08:27.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = array.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((array[j] % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (array[j - <span class="number">1</span>]%<span class="number">2</span> == <span class="number">0</span>)) <span class="comment">//前偶后奇交换</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                    array[j-<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>类似于冒泡排序，每次i遍历使得离开头最近的奇数到array[i]位置，当所有奇数均在前面时，剩下的偶数自然就在数组后方，且顺序不变。<br>从后往前，当array[j-1]与array[j]为偶奇时，交换二者的位置。因为所有的交换均是相邻的奇偶位，所以不会对原有的奇偶数顺序造成破坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 12 纯数学方法求幂次方</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-12-%E7%BA%AF%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95%E6%B1%82%E5%B9%82%E6%AC%A1%E6%96%B9/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-12-纯数学方法求幂次方/</id>
    <published>2019-08-24T11:01:38.000Z</published>
    <updated>2019-08-24T11:26:17.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = exponent;</span><br><span class="line">        <span class="keyword">double</span> dev = base;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result *= dev;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            dev *= dev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &gt; <span class="number">0</span> ? result : (<span class="number">1</span> / result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>因为是纯数学方法，所以要用数学的方法解决问题。<br>比如7^13=7^1101=7^1000x7^100x7^1=7^8x7^4x7^1<br>因此利用&amp;操作取末位，若为1则乘，再移位。<br>本质：将任意一个数化为二进制后均为，1,2,4,8……，即转化为基数的一次，二次，四次，八次方相乘，利用与操作判定需不需要将当前次幂乘到最后的result中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。&lt;br&gt;保证b
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 11 一个数的二进制中1的个数</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-11-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-11-一个数的二进制中1的个数/</id>
    <published>2019-08-24T08:31:14.000Z</published>
    <updated>2019-08-24T09:01:27.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!= <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>如果一个整数不为0，那么他的二进制形式至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.</p><p>一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 10 矩形覆盖</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-10-矩形覆盖/</id>
    <published>2019-08-24T08:27:06.000Z</published>
    <updated>2019-08-24T09:01:31.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target ==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>这题就是斐波那契数列的变体~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 9 变态跳箱子</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-9-%E5%8F%98%E6%80%81%E8%B7%B3%E7%AE%B1%E5%AD%90/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-9-变态跳箱子/</id>
    <published>2019-08-24T04:36:17.000Z</published>
    <updated>2019-08-24T04:53:31.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>1.n=1 一种跳法，跳一个格子，f(1)=1<br>2.n=2 两种跳法，跳一个或者两个格子，跳了1个格子之后面临的情形和1中一样，跳完2个格子到到终点，f(2)=f(2-1)+f(2-2)<br>3.n=3 三种跳法，一个、两个、三个，跳了1个格子之后面临的情形和2中一样，跳了2个格子之后面临的情形和1中一样，三个跳完到达终点，f(3)=f(3-1)+f(3-2)+f(3-1)<br>f(n)=f(0)+…+f(n-2)+f(n-1)<br>f(n-1)=f(0)+…+f(n-2)<br>所以f(n)=2f(n-1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 8 跳格子问题</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-8-%E8%B7%B3%E6%A0%BC%E5%AD%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-8-跳格子问题/</id>
    <published>2019-08-24T03:29:13.000Z</published>
    <updated>2019-08-24T03:40:07.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target ==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>a.从头到尾，没跳之前一共有n个格子，那就有f(n)种跳法；<br>  情况一：第一步！跳1步，那剩下来还有n-1个格子，就是有f(n-1)种跳法；<br>  情况二：第一步！跳2步，那剩下来还有n-2个格子，就是有f(n-2)种跳法；<br>所以，可以得出总跳法为: f(n) = f(n-1) + f(n-2) </p><p>d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p><p>e.可以发现最终得出的是一个斐波那契数列!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 7 斐波那契数列问题</title>
    <link href="http://yoursite.com/2019/08/24/codingNow-7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/24/codingNow-7-斐波那契数列问题/</id>
    <published>2019-08-24T02:01:36.000Z</published>
    <updated>2019-08-24T02:56:15.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39<br>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, current = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != n) &#123;</span><br><span class="line">            current += pre;</span><br><span class="line">            pre = current - pre;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, current = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current += pre;</span><br><span class="line">            pre = current - pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>1.这题用递归简直完美，但是会存在重复计算的问题，而且重复计算量十分巨大，如果一定要用递归的话，可以另外建立一个历史数组用以缓存。<br>2.动态规划十分好用，也十分简单，消耗内存小。小改进，利用n。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&lt;br&gt;n&amp;lt;=3
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 6 旋转数组的二分查找</title>
    <link href="http://yoursite.com/2019/08/23/codingNow-6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2019/08/23/codingNow-6-旋转数组的二分查找/</id>
    <published>2019-08-23T12:56:30.000Z</published>
    <updated>2019-08-24T02:02:46.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>, end = array.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid] &lt; array[end]) &#123;</span><br><span class="line">                    end = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; array[end]) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> array[end];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>基本思路：对一个费降序的序列进行旋转，取三个点：start，mid，end。会出现三种情况<br>（1）array[mid]&gt;array[end]，例如[4 5 6 6 6 2 3],因为首一定大尾一，可以认为这种情况下start到mid均为非降序（连续），所以转折点在mid到end之间。<br>（2）array[mid]&lt;array[end]，可以认为这种情况下mid到end均为非降序（连续），所以转折点在start到mid之间。<br>（3）array[mid]=array[end]，例如[0 0 0 0 0 1 0]，只能一个个判断了。<br>一个注意点，如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字，假如array只有两个元素[1,2]，则array[start]=1.array[end]=2，array[mid]=1，如果此时end=mid-1=0-1=-1，错误，所以end=mid；（根源在于只剩两个数，那么mid 一定会指向下标靠前的数字，所以加一可以，减一再往前就越界了）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个非递减排序的数组的一个旋转，输出旋转数组的
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 5 用两个栈实现队列</title>
    <link href="http://yoursite.com/2019/08/23/codingNow-5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/08/23/codingNow-5-用两个栈实现队列/</id>
    <published>2019-08-23T08:30:09.000Z</published>
    <updated>2019-08-24T02:02:47.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>基本思路：<br>1.push：直接push进stack1。<br>2.pop： 首先检查是否均为空，是则报空指针。剩余两种情况，一是stack2为空，也就是说stack2里面的所有栈都被清除出去或者是尚未放入元素，则将stack1中的元素依次pop后压入stack2，再实现pop功能。二是stack中不为空，直接返回stack2.pop()。<br>3.其中peek和pop区别在于pop会返回栈顶元素并且弹出元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 4 还原二叉树</title>
    <link href="http://yoursite.com/2019/08/23/codingNow-4-%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/08/23/codingNow-4-还原二叉树/</id>
    <published>2019-08-23T07:26:09.000Z</published>
    <updated>2019-08-24T02:02:48.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">            TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[i]==pre[startPre])&#123;</span><br><span class="line">                    node.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, i - startIn + startPre, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">                    node.right = reConstructBinaryTree(pre, i - startIn + startPre + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结，几个注意点"><a href="#个人总结，几个注意点" class="headerlink" title="个人总结，几个注意点"></a>个人总结，几个注意点</h3><p>1.关于二叉树，只有前+中，后+中，层+中才能还原二叉树，其他均不能确定其左右孩子。<br>2.for(int i=startIn;i&lt;=endIn;i++)此处注意&lt;=。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>关于二叉树</title>
    <link href="http://yoursite.com/2019/08/23/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/08/23/关于二叉树/</id>
    <published>2019-08-23T07:12:15.000Z</published>
    <updated>2019-08-23T07:25:31.805Z</updated>
    
    <content type="html"><![CDATA[<p>#二叉树的前序、中序、后序、层序遍历和还原。  #<br>前序ABC，中序BAC，后序BCA。</p><p>一、描绘二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">public</span> Node leftChild;</span><br><span class="line">    <span class="keyword">public</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二、二叉树的遍历<br>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(name); <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild != null) &#123;</span><br><span class="line">        result.append(leftChild.readPre());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightChild != null) &#123;</span><br><span class="line">        result.append(rightChild.readPre());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readMid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (leftChild != null) &#123;</span><br><span class="line">        result.append(leftChild.readMid());</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(name); <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild != null) &#123;</span><br><span class="line">        result.append(rightChild.readMid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (leftChild != null) &#123;</span><br><span class="line">        result.append(leftChild.readEnd());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightChild != null) &#123;</span><br><span class="line">        result.append(rightChild.readEnd());</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(name); <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，前序、中序、后序遍历的算法基本上差不多，其主要是在对根节点的访问顺序不同，然后利用递归的方式来进行实现。</p><p>层序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="built_in">queue</span>.offer(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            Node curNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">            result.append(curNode.name);</span><br><span class="line">            <span class="keyword">if</span> (curNode.leftChild != null) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.offer(curNode.leftChild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.rightChild != null) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.offer(curNode.rightChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟其他遍历不同，层序遍历需要借助队列来进行实现。首先将根节点放到队列中，然后遍历循环，依次将左孩子和右孩子放置到队列中。</p><p>三、还原二叉树<br>在第二章节中，获得到前序、中序、后序、层序的结果依次如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         String pre = <span class="string">"ABDGHCEIF"</span>; <span class="comment">//前序遍历</span></span><br><span class="line"><span class="number">2</span>         String mid = <span class="string">"GDHBAEICF"</span>; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="number">3</span>         String end = <span class="string">"GHDBIEFCA"</span>; <span class="comment">//后序遍历</span></span><br><span class="line"><span class="number">4</span>         String level = <span class="string">"ABCDEFGHI"</span>; <span class="comment">//层序遍历</span></span><br></pre></td></tr></table></figure><p>那能否通过上面的字符串还原出二叉树的的形状呢？这个分情况讨论</p><p>前序+中序：</p><p>思路：通过前序获得根节点的位置，利用根节点将中序序列分为左子树和右子树，然后不断的递归划分即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前序和中序排序表获取树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTreeByPreMid</span><span class="params">(<span class="keyword">char</span>[] pre, <span class="keyword">int</span> preBegin, <span class="keyword">int</span> preEnd, <span class="keyword">char</span>[] mid, <span class="keyword">int</span> midBegin, <span class="keyword">int</span> midEnd)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node();</span><br><span class="line">        root.setName(pre[preBegin] + <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> midRootLoc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = midBegin; i &lt;= midEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid[i] == pre[preBegin]) &#123;</span><br><span class="line">                midRootLoc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归得到左子树</span></span><br><span class="line">        <span class="keyword">if</span> (preBegin + (midRootLoc - midBegin) &gt;= preBegin + <span class="number">1</span> &amp;&amp; (midRootLoc - <span class="number">1</span>) &gt;= midBegin) &#123;</span><br><span class="line">            Node leftChild = buildTreeByPreMid(pre, preBegin + <span class="number">1</span>, preBegin + (midRootLoc - midBegin),</span><br><span class="line">                    mid, midBegin, midRootLoc - <span class="number">1</span>);</span><br><span class="line">            root.leftChild = leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归得到右子树</span></span><br><span class="line">        <span class="keyword">if</span> (preEnd &gt;= (preEnd - (midEnd - midRootLoc) + <span class="number">1</span>) &amp;&amp; (midEnd &gt;= midRootLoc + <span class="number">1</span>)) &#123;</span><br><span class="line">            Node rightChild = buildTreeByPreMid(pre, preEnd - (midEnd - midRootLoc) + <span class="number">1</span>, preEnd,</span><br><span class="line">                    mid, midRootLoc + <span class="number">1</span>, midEnd);</span><br><span class="line">            root.rightChild = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后序+中序：<br>思路：通过后序获取根节点的位置，然后在中序中划分左子树和右子树，然后递归划分即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据后序和中序遍历还原树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTreeByMidEnd</span><span class="params">(<span class="keyword">char</span>[] mid, <span class="keyword">int</span> midBegin, <span class="keyword">int</span> midEnd, <span class="keyword">char</span>[] end, <span class="keyword">int</span> endBegin, <span class="keyword">int</span> endEnd)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node();</span><br><span class="line">        root.setName(end[endEnd] + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> midRootLoc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = midEnd; i &gt;= midBegin; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid[i] == end[endEnd]) &#123;</span><br><span class="line">                midRootLoc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原左子树</span></span><br><span class="line">        <span class="keyword">if</span> (midRootLoc - <span class="number">1</span> &gt;= midBegin &amp;&amp; (endBegin + (midRootLoc - midBegin) - <span class="number">1</span> &gt;= endBegin)) &#123;</span><br><span class="line">            Node leftChild = buildTreeByMidEnd(mid, midBegin, midRootLoc - <span class="number">1</span>, end, endBegin, endBegin + (midRootLoc - midBegin) - <span class="number">1</span>);</span><br><span class="line">            root.leftChild = leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原右子树</span></span><br><span class="line">        <span class="keyword">if</span> (midEnd &gt;= midRootLoc + <span class="number">1</span> &amp;&amp; (endEnd - <span class="number">1</span> &gt;= endEnd - (midEnd - midRootLoc))) &#123;</span><br><span class="line">            Node rightChild = buildTreeByMidEnd(mid, midRootLoc + <span class="number">1</span>, midEnd, end, endEnd - (midEnd - midRootLoc), endEnd - <span class="number">1</span>);</span><br><span class="line">            root.rightChild = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>层序+中序：</p><p>思路：根据层序遍历获取根节点的位置，然后将中序划分为左子树和右子树，然后根据划分出的左子树和右子树分别在层序遍历中获取其对应的层序顺序，然后递归调用划分即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据层序遍历和中序遍历得到结果</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTreeByMidLevel</span><span class="params">(<span class="keyword">char</span>[] mid, <span class="keyword">char</span>[] level, <span class="keyword">int</span> midBegin, <span class="keyword">int</span> midEnd)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(level[<span class="number">0</span>] + <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> midLoc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = midBegin; i &lt;= midEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid[i] == level[<span class="number">0</span>]) &#123;</span><br><span class="line">                midLoc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (level.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeft(mid, level[<span class="number">0</span>], level[<span class="number">1</span>])) &#123;</span><br><span class="line">                Node left = buildTreeByMidLevel(mid, getLevelStr(mid, midBegin, midLoc - <span class="number">1</span>, level), midBegin, midLoc - <span class="number">1</span>);</span><br><span class="line">                root.leftChild = left;</span><br><span class="line">                <span class="keyword">if</span> (level.length &gt;= <span class="number">3</span> &amp;&amp; !isLeft(mid, level[<span class="number">0</span>], level[<span class="number">2</span>])) &#123;</span><br><span class="line">                    Node right = buildTreeByMidLevel(mid, getLevelStr(mid, midLoc + <span class="number">1</span>, midEnd, level), midLoc + <span class="number">1</span>, midEnd);</span><br><span class="line">                    root.rightChild = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node right = buildTreeByMidLevel(mid, getLevelStr(mid, midLoc + <span class="number">1</span>, midEnd, level), midLoc + <span class="number">1</span>, midEnd);</span><br><span class="line">                root.rightChild = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将中序序列中midBegin与MidEnd的字符依次从level中提取出来，保持level中的字符顺序不变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] getLevelStr(<span class="keyword">char</span>[] mid, <span class="keyword">int</span> midBegin, <span class="keyword">int</span> midEnd, <span class="keyword">char</span>[] level) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[midEnd - midBegin + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> curLoc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (contains(mid, level[i], midBegin, midEnd)) &#123;</span><br><span class="line">                result[curLoc++] = level[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果str字符串的begin和end位置之间（包括begin和end）含有字符target,则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> boolean <span class="title">contains</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span> target, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的遍历组合均不能还原出二叉树的形状，因为无法确认其左右孩子。例如，前序为AB，后序为AB，则无法确认出，B节点是A节点的左孩子还是右孩子，因此无法还原。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#二叉树的前序、中序、后序、层序遍历和还原。  #&lt;br&gt;前序ABC，中序BAC，后序BCA。&lt;/p&gt;
&lt;p&gt;一、描绘二叉树&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
      <category term="浅析java" scheme="http://yoursite.com/tags/%E6%B5%85%E6%9E%90java/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 3 从头到尾打印空格</title>
    <link href="http://yoursite.com/2019/08/22/codingNow-3-%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/08/22/codingNow-3-从头到尾打印空格/</id>
    <published>2019-08-22T08:05:18.000Z</published>
    <updated>2019-08-24T02:02:48.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>方法一：利用堆栈，单个读取存入栈中，再逐个pop,实线从后往前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != null) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">        Integer pop = <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="built_in">list</span>.add(pop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        或者利用arr的特性，在零位添加元素类似于对于堆栈进行push</span></span><br><span class="line"><span class="comment">//        while (listNode != null) &#123;</span></span><br><span class="line"><span class="comment">//            list.add(0, listNode.val);</span></span><br><span class="line"><span class="comment">//            listNode = listNode.next;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归，并利用list.add的类似堆栈特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        <span class="keyword">while</span> (listNode!=null)&#123;</span><br><span class="line">            <span class="built_in">list</span>.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">            printListFromTailToHead(listNode);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：在递归的基础上利用了递归的特性，到尾反向执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode!=null)&#123;</span><br><span class="line">            <span class="keyword">this</span>.printListFromTailToHead(listNode.next);</span><br><span class="line">            <span class="built_in">list</span>.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结，几个注意点"><a href="#个人总结，几个注意点" class="headerlink" title="个人总结，几个注意点"></a>个人总结，几个注意点</h3><p>1.如果需要倒置或者反向一类的操作，利用stack可以完成，但是内存消耗较大，效率低。<br>2.list的add（0，xxx）可以做到stack的push操作。<br>3.递归的性质，重复执行，到尾反向传播。第三种方法中利用了递归积攒了大量的add操作未完成，直到最后listNode为空时，返回了空的list，开始完成之前积攒的嵌套add操作，同时也完成了反向的操作。（我怀疑出题者是写出了这个递归之后，才想出来的题目，哈哈，出题者有一点点炫技的嫌疑0.0）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个链表，按链表从尾到头的顺序返回一个ArrayList。&lt;/p&gt;
&lt;p&gt;方法一：利用堆栈，单个读取存入栈中，再逐个po
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 2 替换空格</title>
    <link href="http://yoursite.com/2019/08/22/codingNow-2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/08/22/codingNow-2-替换空格/</id>
    <published>2019-08-22T06:19:00.000Z</published>
    <updated>2019-08-24T02:02:50.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，把字符串中的每个空格替换成”%20”，例如“We are happy.“，则输出”We%20are%20happy”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> usedlength = str.length();</span><br><span class="line">        <span class="keyword">if</span> (str == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> whitespace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; usedlength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                whitespace++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetlength = whitespace * <span class="number">2</span> + usedlength;</span><br><span class="line">        str.setLength(targetlength);</span><br><span class="line"></span><br><span class="line">        targetlength--;</span><br><span class="line">        usedlength--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = usedlength ; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(targetlength , str.charAt(i));</span><br><span class="line">                targetlength--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                str.setCharAt(targetlength , <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(--targetlength, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(--targetlength, <span class="string">'%'</span>);</span><br><span class="line">                targetlength--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="个人总结，几个个注意点"><a href="#个人总结，几个个注意点" class="headerlink" title="个人总结，几个个注意点"></a>个人总结，几个个注意点</h3><p>1.–targetlength和targetlength– 的区别，此处应该是需要先减后setCharAt。<br>2.预先对targetlength和usedlength处理，可以避免后续的繁杂思考。<br>3.考虑从后往前，这样每个字符可以只移动一次，就可以到达目标位置，而且可以在原有字符串上操作，避免了开辟新的内存空间存储新的字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请实现一个函数，把字符串中的每个空格替换成”%20”，例如“We are happy.“，则输出”We%20are%20ha
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>codingNow 1 二维数组的查找</title>
    <link href="http://yoursite.com/2019/08/21/codingNow-1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2019/08/21/codingNow-1-二维数组的查找/</id>
    <published>2019-08-21T12:40:28.000Z</published>
    <updated>2019-08-24T02:02:51.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束：<br>如果该数字大于要查找的数字，剔除这个数字所在的列：如果该数字小于要查找的数字，剔除这个数字所在的行。<br>也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除）行或者一列，这样每一步都可以缩小<br>查找的范围，直到找到要查找的数字，或者查找范围为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span> == null || <span class="built_in">array</span>.length &lt; <span class="number">1</span> || <span class="built_in">array</span>[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = <span class="built_in">array</span>.length; <span class="comment">// 数组的行数</span></span><br><span class="line">        <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].length; <span class="comment">// 数组行的列数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>; <span class="comment">// 起始开始的行号</span></span><br><span class="line">        <span class="keyword">int</span> col = cols - <span class="number">1</span>; <span class="comment">// 起始开始的列号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要查找的位置确保在数组之内</span></span><br><span class="line">        <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] == target) &#123; <span class="comment">// 如果找到了就直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] &gt; target) &#123; <span class="comment">// 如果找到的数比要找的数大，说明要找的数在当前数的左边</span></span><br><span class="line">                col--; <span class="comment">// 列数减一，代表向左移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果找到的数比要找的数小，说明要找的数在当前数的下边</span></span><br><span class="line">                row++; <span class="comment">// 行数加一，代表向下移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] <span class="built_in">array</span> = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">7</span>));    <span class="comment">// 要查找的数在数组中</span></span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">5</span>));    <span class="comment">// 要查找的数不在数组中</span></span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">1</span>));    <span class="comment">// 要查找的数是数组中最小的数字</span></span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">15</span>));   <span class="comment">// 要查找的数是数组中最大的数字</span></span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">0</span>));    <span class="comment">// 要查找的数比数组中最小的数字还小</span></span><br><span class="line">        System.out.println(find1(<span class="built_in">array</span>, <span class="number">16</span>));   <span class="comment">// 要查找的数比数组中最大的数字还大</span></span><br><span class="line">        System.out.println(find1(null, <span class="number">16</span>));     <span class="comment">// 健壮性测试，输入空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">find1</span><span class="params">(<span class="keyword">int</span>[][] <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span> == null || <span class="built_in">array</span>.length &lt; <span class="number">1</span> || <span class="built_in">array</span>[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">array</span>.length;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">array</span>[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = b - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; a &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[x][y] &lt; target) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;br&gt;请完成一个函数，输
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 26 号问题：删除排序数组中的重复项</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC26%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第26号问题：删除排序数组中的重复项/</id>
    <published>2019-08-21T09:21:23.000Z</published>
    <updated>2019-08-21T05:52:15.238Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 26 号问题：删除排序数组中的重复项。题目难度为 Easy，目前通过率为 48.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181116115601.gif" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) return 0;</span><br><span class="line">        int pre = 0, cur = 0, n = nums.size();</span><br><span class="line">        while (cur &lt; n) &#123;</span><br><span class="line">            if (nums[pre] == nums[cur])&#123;</span><br><span class="line">              cur++;  </span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ++pre;</span><br><span class="line">                nums[pre] = nums[cur];</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return pre + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/fz0rq.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 26 号问题：删除排序数组中的重复项。题目难度为 Easy，目前通过率为 48.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 21 号问题：合并两个有序链表</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC21%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第21号问题：合并两个有序链表/</id>
    <published>2019-08-21T07:52:31.000Z</published>
    <updated>2019-08-21T05:52:16.220Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。题目难度为 Easy，目前通过率为 45.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h4 id="一般方案"><a href="#一般方案" class="headerlink" title="一般方案"></a>一般方案</h4><h5 id="1-1-解题思想"><a href="#1-1-解题思想" class="headerlink" title="1.1 解题思想"></a>1.1 解题思想</h5><blockquote><p>（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（两个都为空此情况在pHead1为空已经被拦截）<br>（2）在两个链表无空链表的情况下确定第一个结点，比较链表1和链表2的第一个结点的值，将值小的结点保存下来为合并后的第一个结点。并且把第一个结点为最小的链表向后移动一个元素。<br>（3）继续在剩下的元素中选择小的值，连接到第一个结点后面，并不断next将值小的结点连接到第一个结点后面，直到某一个链表为空。<br>（4）当两个链表长度不一致时，也就是比较完成后其中一个链表为空，此时需要把另外一个链表剩下的元素都连接到第一个结点的后面。</p></blockquote><h5 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoOrderedLists</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;</span><br><span class="line">    ListNode* pTail = <span class="literal">NULL</span>;<span class="comment">//指向新链表的最后一个结点 pTail-&gt;next去连接</span></span><br><span class="line">    ListNode* newHead = <span class="literal">NULL</span>;<span class="comment">//指向合并后链表第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead2)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//确定头指针</span></span><br><span class="line">        <span class="keyword">if</span> ( pHead1-&gt;data &lt; pHead2-&gt;data)&#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;<span class="comment">//指向链表的第二个结点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pTail = newHead;<span class="comment">//指向第一个结点</span></span><br><span class="line">        <span class="keyword">while</span> ( pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( pHead1-&gt;data &lt;= pHead2-&gt;data )&#123;</span><br><span class="line">                pTail-&gt;next = pHead1;  </span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                pTail-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = pTail-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">            pTail-&gt;next = pHead2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead2)&#123;</span><br><span class="line">            pTail-&gt;next = pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归方案"><a href="#2-递归方案" class="headerlink" title="2 递归方案"></a>2 递归方案</h4><h5 id="2-1-解题思想"><a href="#2-1-解题思想" class="headerlink" title="2.1 解题思想"></a>2.1 解题思想</h5><blockquote><p>（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。<br>（2）比较两个链表第一个结点的大小，确定头结点的位置<br>（3）头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复（2 ）（3） 步，直到有链表为空。</p></blockquote><h5 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoOrderedLists</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;</span><br><span class="line">    ListNode* newHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> ==pHead2)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;data &lt; pHead2-&gt;data)&#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            newHead-&gt;next = mergeTwoOrderedLists(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            newHead-&gt;next = mergeTwoOrderedLists(pHead1, pHead2-&gt;next);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/fz0rq.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。题目难度为 Easy，目前通过率为 45.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
