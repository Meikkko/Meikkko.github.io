<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-12T09:05:28.282Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5 适配器设计模式</title>
    <link href="http://yoursite.com/2019/10/11/5-%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/11/5-适配器设计模式/</id>
    <published>2019-10-11T03:18:05.000Z</published>
    <updated>2019-10-12T09:05:28.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器<br>2)适配器 模式属于结构型模式<br>3)主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被适配的类</span><br><span class="line"> */</span><br><span class="line">public class Voltage220V &#123;</span><br><span class="line">    public int output220V()&#123;</span><br><span class="line">        //输出220V电压</span><br><span class="line">        int src = 220;</span><br><span class="line">        System.out.println(&quot;电压=&quot; + src + &quot;伏特&quot;);</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配接口</span><br><span class="line"> */</span><br><span class="line">public interface IVoltage5V &#123;</span><br><span class="line">    public int output5V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter extends Voltage220V implements IVoltage5V&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    //充电</span><br><span class="line">    public void charging(IVoltage5V iVoltage5V)&#123;</span><br><span class="line">        if (iVoltage5V.output5V() == 5) &#123;</span><br><span class="line">            System.out.println(&quot;电压为5V，正在充电&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;电压出错，无法充电&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类适配器模式注意事项和细节<br>1)Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点因为这要求dst必须是接口，有一定局限性.<br>2)src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本 。<br>3)由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得Adapter的灵活性增强了</p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>1)基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承src 类，而是持有 src 类的实例，以解决兼容性的问题。 即持有 src 类，实现 dst 类接口，完成src–&gt;dst 的适配<br>2)根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。<br>3)对象适配器模式是适配器模式常用的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器</span><br><span class="line"> */</span><br><span class="line">public class VoltageAdapter implements IVoltage5V&#123;</span><br><span class="line">    </span><br><span class="line">    private Voltage220V voltage220V;</span><br><span class="line">    </span><br><span class="line">    //不再集成，而是通过关联关系中的聚合</span><br><span class="line">    //即利用构造方法传入一个Voltage220V的实例</span><br><span class="line">    public VoltageAdapter(Voltage220V voltage220V) &#123;</span><br><span class="line">        this.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int output5V() &#123;</span><br><span class="line">        int src = voltage220V.output220V();</span><br><span class="line">        int dst = src / 44;</span><br><span class="line">        return dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        phone.charging(new VoltageAdapter(new Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h2><p>1)一些书籍称为：适配器模式 (Default Adapter或缺省适配器模式<br>2)当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需 求<br>3)适用于一个接口不想使用其所有的方法的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface4 &#123;</span><br><span class="line">    public void m1();</span><br><span class="line">    public void m2();</span><br><span class="line">    public void m3();</span><br><span class="line">    public void m4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在抽象类中空实现所有方法</span><br><span class="line">public abstract class AbsAdapter implements Interface4 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void m1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void m4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbsAdapter adapter = new AbsAdapter() &#123;</span><br><span class="line">            //只需覆盖我们需要使用的接口方法</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void m1() &#123;</span><br><span class="line">                System.out.println(&quot;使用了m1方法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        adapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>适配器模式在SpringMVC框架应用<br><img src="https://upload-images.jianshu.io/upload_images/18958678-ed3140e11d339369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/18958678-a0cd9b8752ee4232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)适配器模式 (Adapter 将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>4 建造者设计模式</title>
    <link href="http://yoursite.com/2019/10/10/4-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/10/4-建造者设计模式/</id>
    <published>2019-10-10T07:21:12.000Z</published>
    <updated>2019-10-11T03:18:15.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1.适用场景：<br>1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果<br>2)多个部件都可以装配到一个对象中，但产生的运行结果不相同<br>3)产品类非常复杂或者产品类因为调用顺序不同而产生不同作用<br>4)初始化一个对象时，参数过多，或者很多参数具有默认值<br>5)Builder模式不适合创建差异性很大的产品类<br>6)产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本<br>7)需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</p><p>2.建造者模式的四个角色<br>1)Product （产品角色一个具体的产品对象 。<br>2)Builder （抽象建造者 创建一个Product对象的各个部件指定的接口抽象类 。<br>3)ConcreteBuilder （具体建造者实现接口，构建和装配各个部件 。<br>4)Director （指挥者 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。<br><img src="https://upload-images.jianshu.io/upload_images/18958678-732af724ba70d047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="具体对象"><a href="#具体对象" class="headerlink" title="具体对象"></a>具体对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">    private String baise;</span><br><span class="line">    private String wall;</span><br><span class="line">    private String roofed;</span><br><span class="line">//getter和setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象的建造者</span><br><span class="line"> */</span><br><span class="line">public abstract class HouseBuilder &#123;</span><br><span class="line">    protected House house = new House();</span><br><span class="line"></span><br><span class="line">    //建造的抽象流程</span><br><span class="line">    public abstract void buildBasic();</span><br><span class="line">    public abstract void buildWalls();</span><br><span class="line">    public abstract void roofed();</span><br><span class="line"></span><br><span class="line">    //造好房子，将房子返回</span><br><span class="line">    public House buildHouse()&#123;</span><br><span class="line">        return house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CommonHouse extends HouseBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildBasic() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子打地基5米&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildWalls() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子建墙四堵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void roofed() &#123;</span><br><span class="line">        System.out.println(&quot;普通房子造天花板&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指挥者</span><br><span class="line"> */</span><br><span class="line">public class HouseDirector &#123;</span><br><span class="line"></span><br><span class="line">    HouseBuilder houseBuilder = null;</span><br><span class="line"></span><br><span class="line">    //构造器传入houseBuilder</span><br><span class="line">    public HouseDirector(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过setter传入houseBuilder</span><br><span class="line">    public void setHouseBuilder(HouseBuilder houseBuilder) &#123;</span><br><span class="line">        this.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指挥者指挥建造的房子的流程</span><br><span class="line">    public House constructHouse()&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        return houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //盖普通房子</span><br><span class="line">        CommonHouse commonHouse = new CommonHouse();</span><br><span class="line">        //准备指挥者</span><br><span class="line">        HouseDirector houseDirector = new HouseDirector(commonHouse);</span><br><span class="line">        //完成</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>建造者设计模式在JDK中java.lang.StringBuilder中的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client.java</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(&quot;sss&quot;);</span><br><span class="line"></span><br><span class="line">StringBuilder.java</span><br><span class="line">public final class StringBuilder</span><br><span class="line">extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder.java</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br></pre></td></tr></table></figure><p>1.Appendable接口定义了多个append抽象方法，所以Appendable为抽象建造者，定义了抽象方法；<br>2.AbstractStringBuilder实现了Appendable方法，所以AbstractStringBuilder是建造者，只是不能实例化<br>3.StringBuilder既是指挥者，又是具体的建造者，比如建造方法的实现是由 AbstractStringBuilder 完成 , 而 StringBuilder 继承了<br>AbstractStringBuilder。</p><p>4.建造者模式与抽象工厂模式的比较:<br>1)与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。<br>2)在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。<br>3)如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1.适用场景：&lt;br&gt;1)隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果&lt;br&gt;2)多个部件都可以装配
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>3 原型模式</title>
    <link href="http://yoursite.com/2019/10/09/3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/09/3-原型模式/</id>
    <published>2019-10-09T06:58:29.000Z</published>
    <updated>2019-10-10T08:25:52.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>2)原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象无需知道如何创建的细节<br>3)工作原理是 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone。<br>4)二者只是属性相同，并不是同一个<br>5)对象.clone是浅拷贝<br>6)深克隆两种方法：1.重写clone方法。2.通过对象的序列化实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Sheep implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sheep = (Sheep) super.clone();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return sheep;</span><br><span class="line">    &#125;</span><br><span class="line">//......</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Sheep sheep = new Sheep(&quot;Tom&quot;, 1, &quot;White&quot;);</span><br><span class="line">        Sheep cloned1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned3 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep cloned4 = (Sheep) sheep.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(cloned1);</span><br><span class="line">        System.out.println(cloned2);</span><br><span class="line">        System.out.println(cloned3);</span><br><span class="line">        System.out.println(cloned4);</span><br><span class="line">        System.out.println(cloned1==cloned2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">Sheep&#123;name=&apos;Tom&apos;, age=1, color=&apos;White&apos;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h2><p>1)Spring 中原 型 bean 的创建，就是原型模式的应用,核心代码在doGetBean中对mdb.isSingleton()或者mdb.isPrototype之后，获取原型。<br>2)代码分析 +Debug 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beans.xml</span><br><span class="line">&lt;bean id= id=&quot;id01&quot; class=&quot;com.atguigu.spring.bean.Monster&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line">ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">//获取 monster[ 通过 id 获取 monster]</span><br><span class="line">Object bean = applicationContext.getBean(&quot;id01&quot;);</span><br><span class="line">System.out.println(&quot;bean&quot; + bean);</span><br></pre></td></tr></table></figure><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>数据类型分为两种基础类型和引用类型：<br>1、基础类型：像Number、String、Boolean等这种为基本类型<br>2、引用类型：Object和Array<br>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class Sheep implements Cloneable implements Serializable, Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String color;</span><br><span class="line">    public DeepCloneableTarget deepCloneableTarget;</span><br><span class="line"></span><br><span class="line">    //方式一：重写clone方法</span><br><span class="line">    //1.基本类型，直接super处理，不用单独处理</span><br><span class="line">    //2.引用类型，对此直接调用该引用对象自身的clone方法</span><br><span class="line">    //这种方法真的要写需要递归，分支较大，复杂度不可预知，不推荐</span><br><span class="line"></span><br><span class="line">    //方式二：利用对象的序列化实现</span><br><span class="line">    public Object deepClone() &#123;</span><br><span class="line"></span><br><span class="line">        //创建流对象</span><br><span class="line">        ByteArrayOutputStream bos = null;</span><br><span class="line">        ObjectOutputStream oos = null;</span><br><span class="line">        ByteArrayInputStream bis = null;</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            //序列化</span><br><span class="line">            bos = new ByteArrayOutputStream();</span><br><span class="line">            oos = new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this); //当前这个对象以对象流的方式输出</span><br><span class="line"></span><br><span class="line">            //反序列化</span><br><span class="line">            bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = new ObjectInputStream(bis);</span><br><span class="line">            Object copyObj = ois.readObject();</span><br><span class="line"></span><br><span class="line">            return copyObj;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭流</span><br><span class="line">            try &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; catch (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1)原型模式 Prototype 模式是指：用原 型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;br&gt;2)原型
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2 工厂设计模式</title>
    <link href="http://yoursite.com/2019/09/27/2-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/27/2-工厂设计模式/</id>
    <published>2019-09-27T10:18:26.000Z</published>
    <updated>2019-10-10T09:30:45.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//披萨类</span><br><span class="line">public class Pizza &#123;</span><br><span class="line">    public void prepare1()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void prepare2()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void prepare3()&#123;</span><br><span class="line">        System.out.println(&quot;准备工作3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//GreekPizza</span><br><span class="line">public class GreekPizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare1() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare2() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare3() &#123;</span><br><span class="line">        System.out.println(&quot;准备Greek披萨步骤3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//CheesePizza</span><br><span class="line">public class CheesePizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepare1() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare2() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepare3() &#123;</span><br><span class="line">        System.out.println(&quot;准备cheese披萨步骤3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式（静态工厂）"><a href="#简单工厂模式（静态工厂）" class="headerlink" title="简单工厂模式（静态工厂）"></a>简单工厂模式（静态工厂）</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-79265d99dd87135b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFactory &#123;</span><br><span class="line">    public static Pizza createPizza(String OrderType)&#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line"></span><br><span class="line">        if (&quot;Greek&quot;.equals(OrderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(OrderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class OrderPizza &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pizza pizza = SimpleFactory.createPizza(&quot;Greek&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-9915dee5a21cd10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//OrderPizza抽象类</span><br><span class="line">public abstract class OrderPizza &#123;</span><br><span class="line">    abstract Pizza createPizza(String orderType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//北京店</span><br><span class="line">public class BJOrderPizza extends OrderPizza &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//伦敦店</span><br><span class="line">public class LDOrderPizza extends OrderPizza&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//主动订购</span><br><span class="line">public class PizzaStore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//自己选择去哪家店</span><br><span class="line">        BJOrderPizza bjOrderPizza = new BJOrderPizza();</span><br><span class="line">        Pizza pizza = bjOrderPizza.createPizza(&quot;Greek&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法模式"><a href="#抽象方法模式" class="headerlink" title="抽象方法模式"></a>抽象方法模式</h2><p><img src="https://upload-images.jianshu.io/upload_images/18958678-06c6a92e3ead8136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbsFactory &#123;</span><br><span class="line">    public Pizza createPizza(String orderType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BJFactory implements AbsFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LDFactory implements AbsFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Pizza createPizza(String orderType) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        if (&quot;Greek&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new GreekPizza();</span><br><span class="line">        &#125; else if (&quot;Cheese&quot;.equals(orderType)) &#123;</span><br><span class="line">            pizza = new CheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderPizza &#123;</span><br><span class="line">    public OrderPizza(AbsFactory absFactory) &#123;</span><br><span class="line">        setFactory(absFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setFactory(AbsFactory absFactory) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line">        //模拟定了cheese披萨</span><br><span class="line">        pizza = absFactory.createPizza(&quot;Cheese&quot;);</span><br><span class="line">        pizza.prepare1();</span><br><span class="line">        pizza.prepare2();</span><br><span class="line">        pizza.prepare3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Cilent &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new OrderPizza(new BJFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>工厂方法就是让所有工厂实现了一个抽象方法（通过继承一个抽象类），这样所有的工厂都会生产汽车了，但是具体生产什么汽车还得自己去找对应的厂子。<br>抽象工厂模式就是，抽象出一个工厂接口，所有工厂实现这个接口，实现其中的制造方法，在使用的时候，任意抽象类工厂的实现类都可以被应用到这个位置，不用自己选择。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h1 id="在JDK源码中的应用"><a href="#在JDK源码中的应用" class="headerlink" title="在JDK源码中的应用"></a>在JDK源码中的应用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Calendar getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    Locale aLocale = Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">    return createCalendar(defaultTimeZone(aLocale), aLocale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private static Calendar createCalendar(TimeZone zone,</span><br><span class="line">                                       Locale aLocale)</span><br><span class="line">&#123;</span><br><span class="line">    CalendarProvider provider =</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                             .getCalendarProvider();</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">            // fall back to the default instantiation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal = null;</span><br><span class="line"></span><br><span class="line">    if (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">        if (caltype != null) &#123;</span><br><span class="line">//简单工厂模式</span><br><span class="line">            switch (caltype) &#123;</span><br><span class="line">            case &quot;buddhist&quot;:</span><br><span class="line">            cal = new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;japanese&quot;:</span><br><span class="line">                cal = new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;gregory&quot;:</span><br><span class="line">                cal = new GregorianCalendar(zone, aLocale);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cal == null) &#123;</span><br><span class="line">        // If no known calendar type is explicitly specified,</span><br><span class="line">        // perform the traditional way to create a Calendar:</span><br><span class="line">        // create a BuddhistCalendar for th_TH locale,</span><br><span class="line">        // a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">        // a GregorianCalendar for any other locales.</span><br><span class="line">        // NOTE: The language, country and variant strings are interned.</span><br><span class="line">        if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) &#123;</span><br><span class="line">            cal = new BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;</span><br><span class="line">                   &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) &#123;</span><br><span class="line">            cal = new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cal = new GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1 单例设计模式</title>
    <link href="http://yoursite.com/2019/09/27/1-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/27/1-单例设计模式/</id>
    <published>2019-09-27T09:37:57.000Z</published>
    <updated>2019-10-09T07:39:01.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h1 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-懒汉式"><a href="#3-懒汉式" class="headerlink" title="3.懒汉式"></a>3.懒汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-懒汉式-同步方法"><a href="#4-懒汉式-同步方法" class="headerlink" title="4.懒汉式(同步方法)"></a>4.懒汉式(同步方法)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static synchronized Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-懒汉式（同步代码块）"><a href="#5-懒汉式（同步代码块）" class="headerlink" title="5.懒汉式（同步代码块）"></a>5.懒汉式（同步代码块）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(Singleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                        instance = new Singleton();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-双重检查"><a href="#6-双重检查" class="headerlink" title="6.双重检查"></a>6.双重检查</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(Singleton.class)&#123;</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-静态内部类"><a href="#7-静态内部类" class="headerlink" title="7.静态内部类"></a>7.静态内部类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        private static class SingletonInstance &#123;</span><br><span class="line">            private static Singleton INSTANCE = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static Singleton getInstance() &#123;</span><br><span class="line">            return SingletonInstance.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum  Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        public Singleton getInstance()&#123;</span><br><span class="line">            return INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h1 id="单例模式在JDK源码中的应用"><a href="#单例模式在JDK源码中的应用" class="headerlink" title="单例模式在JDK源码中的应用"></a>单例模式在JDK源码中的应用</h1><p>java.lang.Runtime就是经典的单例模式（饿汉式）<br><img src="https://upload-images.jianshu.io/upload_images/18958678-923a98d87b156357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h2&gt;&lt;h1 id=&quot;1-饿汉式（静态常量）&quot;&gt;&lt;a href=&quot;#1-饿汉式（静态常量）&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="设计模式学习笔记" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>依赖关系传递的三种方式</title>
    <link href="http://yoursite.com/2019/09/26/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/26/依赖关系传递的三种方式/</id>
    <published>2019-09-26T03:12:49.000Z</published>
    <updated>2019-09-26T03:57:57.371Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open(ITV itv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open(ITV itv) &#123;</span><br><span class="line">            itv.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose();</span><br><span class="line">        openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line">        public ITV tv;</span><br><span class="line"></span><br><span class="line">        public OpenAndClose(ITV tv) &#123;</span><br><span class="line">            this.tv = tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open() &#123;</span><br><span class="line">            this.tv.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyPass &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  通过接口实现依赖</span><br><span class="line">     */</span><br><span class="line">    interface ITV&#123;</span><br><span class="line">        public void play();</span><br><span class="line">    &#125;</span><br><span class="line">    interface IOpenAndClose&#123;</span><br><span class="line">        public void open();</span><br><span class="line"></span><br><span class="line">        public void setTV(ITV tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ChangHong implements ITV&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void play() &#123;</span><br><span class="line">            System.out.println(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OpenAndClose implements IOpenAndClose&#123;</span><br><span class="line">        private ITV tv;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open() &#123;</span><br><span class="line">            this.tv.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setTV(ITV tv) &#123;</span><br><span class="line">            this.tv = tv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChangHong changHong = new ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = new OpenAndClose();</span><br><span class="line">        openAndClose.setTV(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Spring源码阅读" scheme="http://yoursite.com/tags/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 36. 有效的数独</title>
    <link href="http://yoursite.com/2019/09/19/leetcode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>http://yoursite.com/2019/09/19/leetcode-36-有效的数独/</id>
    <published>2019-09-19T06:26:54.000Z</published>
    <updated>2019-09-19T06:28:10.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidSudoku(char[][] board) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] rows = new HashMap[9];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] columns = new HashMap[9];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] boxes = new HashMap[9];</span><br><span class="line">        for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            rows[i] = new HashMap&lt;&gt;();</span><br><span class="line">            columns[i] = new HashMap&lt;&gt;();</span><br><span class="line">            boxes[i] = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">                char c = board[i][j];</span><br><span class="line">                if (c != &apos;.&apos;) &#123;</span><br><span class="line">                    int n = (int) c;</span><br><span class="line">                    int box_index = (i / 3) * 3 + j / 3;</span><br><span class="line"></span><br><span class="line">                    rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);</span><br><span class="line">                    columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);</span><br><span class="line">                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);</span><br><span class="line"></span><br><span class="line">                    if (rows[i].get(n) &gt; 1 || columns[j].get(n) &gt; 1 || boxes[box_index].get(n) &gt; 1) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;p&gt;数字 1-9 在每一行
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://yoursite.com/2019/09/18/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/09/18/leetcode-34-在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2019-09-18T04:30:25.000Z</published>
    <updated>2019-09-18T04:30:59.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] ints = new int[2];</span><br><span class="line">        if(nums.length == 0)&#123;</span><br><span class="line">            ints[0] = -1;</span><br><span class="line">            ints[1] = -1;</span><br><span class="line">            return  ints;</span><br><span class="line">        &#125;</span><br><span class="line">        ints[0] = left_bound(nums, target);</span><br><span class="line">        ints[1] = right_bound(nums, target);</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left_bound(int[] nums, int target) &#123;</span><br><span class="line">        if (nums.length == 0)&#123; return -1;&#125;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt;= nums.length - 1 &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int right_bound(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt;= 0 &amp;&amp; nums[right] == target)&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 33. 搜索旋转排序数组</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-33-搜索旋转排序数组/</id>
    <published>2019-09-17T06:09:26.000Z</published>
    <updated>2019-09-17T06:10:20.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:</p><p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int start = 0, end = nums.length - 1;</span><br><span class="line">        while (start &lt;= end) &#123;</span><br><span class="line">            int mid = (start + end) / 2;</span><br><span class="line">            if (nums[mid]==target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            //前半部分有序,注意此处用小于等于</span><br><span class="line">            if (nums[start] &lt;= nums[mid]) &#123;</span><br><span class="line">                //target在前半部分</span><br><span class="line">                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 29. 两数相除</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-29-两数相除/</id>
    <published>2019-09-17T04:04:30.000Z</published>
    <updated>2019-09-17T04:07:07.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>示例 1:</p><p>输入: dividend = 10, divisor = 3<br>输出: 3<br>示例 2:</p><p>输入: dividend = 7, divisor = -3<br>输出: -2<br>说明:</p><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123;</span><br><span class="line">        if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123;</span><br><span class="line">            return Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int flag = 1;</span><br><span class="line">        if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) &#123;</span><br><span class="line">            flag = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dividend &gt; 0) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        if (divisor &gt; 0) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (dividend &lt;= divisor) &#123;</span><br><span class="line">            int k = 1;</span><br><span class="line">            int tempDivisor = divisor;</span><br><span class="line">            //使用tempDivisor每次倍增，到达最大时，记录倍数</span><br><span class="line">            while (dividend &lt;= tempDivisor + tempDivisor &amp;&amp; tempDivisor + tempDivisor &lt; 0) &#123;</span><br><span class="line">                tempDivisor += tempDivisor;</span><br><span class="line">                k += k;</span><br><span class="line">            &#125;</span><br><span class="line">            //记录倍数，减去响应的部分，进行下一次较小的倍增</span><br><span class="line">            dividend -= tempDivisor;</span><br><span class="line">            count += k;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0 ? count : -count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>因为int存储范围，负数边界的绝对值比正数大，负数变成正数会越界，但是正数变成负数不会越界</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="coding-interviews" scheme="http://yoursite.com/tags/coding-interviews/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 24. 两两交换链表中的节点</title>
    <link href="http://yoursite.com/2019/09/17/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/17/leetcode-24-两两交换链表中的节点/</id>
    <published>2019-09-17T03:05:07.000Z</published>
    <updated>2019-09-17T03:06:05.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = new ListNode(0);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        ListNode p1 = pre;</span><br><span class="line">        while (p1.next != null &amp;&amp; p1.next.next != null) &#123;</span><br><span class="line">            ListNode left = p1.next;</span><br><span class="line">            ListNode right = p1.next.next;</span><br><span class="line">            p1.next = right;</span><br><span class="line">            left.next = right.next;</span><br><span class="line">            right.next = left;</span><br><span class="line">            p1 = left;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 22. 括号生成</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-22-括号生成/</id>
    <published>2019-09-16T09:04:24.000Z</published>
    <updated>2019-09-16T09:10:20.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        getIt(&quot;&quot;, n, 0, 0);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getIt(String s, int n, int open, int close) &#123;</span><br><span class="line">        if (s.length() == 2 * n) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if (open &lt; n) &#123;</span><br><span class="line">            getIt(s + &quot;(&quot;, n, open + 1, close);</span><br><span class="line">        &#125;</span><br><span class="line">        if (open &gt; close) &#123;</span><br><span class="line">            getIt(s + &quot;)&quot;, n, open, close + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>添加括号两种情况<br>1.能添加n个左括号，还没加完。<br>2.能添加右括号，从而使它与前面的左括号闭合，即open&gt;close。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 n =
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 19. 删除链表的倒数第N个节点</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-19-删除链表的倒数第N个节点/</id>
    <published>2019-09-16T08:39:15.000Z</published>
    <updated>2019-09-16T08:40:53.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode pre = new ListNode(0);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        ListNode left = pre;</span><br><span class="line">        ListNode right = pre;</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right.next != null) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        return pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>使用right.next != null保证right指针指向最后一个元素时结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.&lt;/p&gt;
&lt;p&gt;当删除了倒数第二个节点
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 18. 四数之和</title>
    <link href="http://yoursite.com/2019/09/16/leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/09/16/leetcode-18-四数之和/</id>
    <published>2019-09-16T06:37:49.000Z</published>
    <updated>2019-09-17T03:05:50.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    //基本思想：k个数的和,先固定k-2个数的位置，通过分层for循环</span><br><span class="line">    //最后通过k=2的时候选出符合条件的进行返回</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (nums.length &lt; 4) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res = kSum(nums, target, 4, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int nums[], int target, int k, int start) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (start &gt;= nums.length) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 2) &#123;</span><br><span class="line">            int left = start;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[left] + nums[right];</span><br><span class="line">                if (sum == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    //去重</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &gt; 2) &#123;</span><br><span class="line">            for (int i = start; i &lt; nums.length - k + 1; i++) &#123;</span><br><span class="line">                ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k - 1, i + 1);</span><br><span class="line">                if (temp != null) &#123;</span><br><span class="line">                    for (List&lt;Integer&gt; e : temp) &#123;</span><br><span class="line">                        e.add(0, nums[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.addAll(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>//此处不用asList，因为asList是一个私有内部类，并不是我们常用的Arraylist<br>//其没有重写add，remove方法，所以只能用于最后一步添加使用<br>//res.add(Arrays.asList(nums[left], nums[right]));</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 17. 电话号码的字母组合</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-17-电话号码的字母组合/</id>
    <published>2019-09-12T06:00:43.000Z</published>
    <updated>2019-09-16T06:37:01.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt></p><p>示例:</p><p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(&quot;2&quot;, &quot;abc&quot;);</span><br><span class="line">        put(&quot;3&quot;, &quot;def&quot;);</span><br><span class="line">        put(&quot;4&quot;, &quot;ghi&quot;);</span><br><span class="line">        put(&quot;5&quot;, &quot;jkl&quot;);</span><br><span class="line">        put(&quot;6&quot;, &quot;mno&quot;);</span><br><span class="line">        put(&quot;7&quot;, &quot;pqrs&quot;);</span><br><span class="line">        put(&quot;8&quot;, &quot;tuv&quot;);</span><br><span class="line">        put(&quot;9&quot;, &quot;wxyz&quot;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if (digits.length() != 0)&#123;</span><br><span class="line">            backtrack(&quot;&quot;, digits);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrack(String s, String next) &#123;</span><br><span class="line">        if (next.length() == 0) &#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            String s1 = map.get(next.substring(0, 1));</span><br><span class="line">            for (int i = 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                //每个分支（线程）代表了一个最终的字符串</span><br><span class="line">                backtrack(s + map.get(next.substring(0, 1)).substring(i, i + 1), next.substring(1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;****</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 16. 最接近的三数之和</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-16-最接近的三数之和/</id>
    <published>2019-09-12T03:25:48.000Z</published>
    <updated>2019-09-12T03:26:33.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int sum = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int res = Math.abs(nums[0] + nums[1] + nums[2] - target);</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = len - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                //记录</span><br><span class="line">                int cursum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                int cur = Math.abs(nums[i] + nums[left] + nums[right] - target);</span><br><span class="line">                if (cur &lt; res) &#123;</span><br><span class="line">                    sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                    res = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                //移动</span><br><span class="line">                if (cursum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (cursum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 tar
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 15. 三数之和</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-15-三数之和/</id>
    <published>2019-09-12T02:44:19.000Z</published>
    <updated>2019-09-12T02:47:44.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br><img src="https://pic.leetcode-cn.com/00a09d9a4652c19ca3d1022b99a2395ae2f874bc4e41d19a4c61434566b156ec-2.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        if (nums == null || len &lt; 3) &#123;</span><br><span class="line">            return lists;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = len - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &gt; 0) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    lists.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    while (left + 1 &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (left + 1 &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 12. 整数转罗马数字</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-12-整数转罗马数字/</id>
    <published>2019-09-11T06:10:18.000Z</published>
    <updated>2019-09-11T06:10:53.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>示例 1:</p><p>输入: 3<br>输出: “III”<br>示例 2:</p><p>输入: 4<br>输出: “IV”<br>示例 3:</p><p>输入: 9<br>输出: “IX”<br>示例 4:</p><p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p><p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        int[] nums = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">        String[] romans = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        while (index &lt; 13) &#123;</span><br><span class="line">            while (num &gt;= nums[index]) &#123;</span><br><span class="line">                num -= nums[index];</span><br><span class="line">                stringBuilder.append(romans[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 3&lt;br&gt;输出: “III”&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: 4&lt;br&gt;输出: “
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 11. 盛最多水的容器</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-11-盛最多水的容器/</id>
    <published>2019-09-11T05:39:54.000Z</published>
    <updated>2019-09-11T05:41:08.580Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例:</p><p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int maxarea = 0, l = 0, r = height.length - 1;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">            if (height[l] &lt;= height[r])</span><br><span class="line">                l++;</span><br><span class="line">            else</span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 8. 字符串转换整数</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-8-字符串转换整数/</id>
    <published>2019-09-11T05:14:13.000Z</published>
    <updated>2019-09-11T05:41:12.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String str) &#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        if (str == null || (str.length() == 0)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        if (str.charAt(0) == &apos;-&apos;) &#123;</span><br><span class="line">            flag = -1;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (str.charAt(0) == &apos;+&apos;) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = start; i &lt; str.length(); i++) &#123;</span><br><span class="line">            char c = str.charAt(i);</span><br><span class="line">            if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int num = c - &apos;0&apos;;</span><br><span class="line">            if ((Integer.MAX_VALUE - num) / 10 &lt; ans) &#123;</span><br><span class="line">                return flag == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * 10 + num;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag == -1 ? -ans :  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>10 * ans + num &gt; Integer.MAX_VALUE不能这么写，要写成(Integer.MAX_VALUE - num) / 10 &lt; ans，因为会越界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h1&gt;&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: “42”&lt;br&gt;输出: 42&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: “   -42”&lt;b
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
