<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meiko</title>
  
  <subtitle>处处见景深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-21T05:52:15.238Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Meiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 第 26 号问题：删除排序数组中的重复项</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC26%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第26号问题：删除排序数组中的重复项/</id>
    <published>2019-08-21T09:21:23.000Z</published>
    <updated>2019-08-21T05:52:15.238Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 26 号问题：删除排序数组中的重复项。题目难度为 Easy，目前通过率为 48.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181116115601.gif" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) return 0;</span><br><span class="line">        int pre = 0, cur = 0, n = nums.size();</span><br><span class="line">        while (cur &lt; n) &#123;</span><br><span class="line">            if (nums[pre] == nums[cur])&#123;</span><br><span class="line">              cur++;  </span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ++pre;</span><br><span class="line">                nums[pre] = nums[cur];</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return pre + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/fz0rq.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 26 号问题：删除排序数组中的重复项。题目难度为 Easy，目前通过率为 48.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 21 号问题：合并两个有序链表</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC21%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第21号问题：合并两个有序链表/</id>
    <published>2019-08-21T07:52:31.000Z</published>
    <updated>2019-08-21T05:52:16.220Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。题目难度为 Easy，目前通过率为 45.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h4 id="一般方案"><a href="#一般方案" class="headerlink" title="一般方案"></a>一般方案</h4><h5 id="1-1-解题思想"><a href="#1-1-解题思想" class="headerlink" title="1.1 解题思想"></a>1.1 解题思想</h5><blockquote><p>（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（两个都为空此情况在pHead1为空已经被拦截）<br>（2）在两个链表无空链表的情况下确定第一个结点，比较链表1和链表2的第一个结点的值，将值小的结点保存下来为合并后的第一个结点。并且把第一个结点为最小的链表向后移动一个元素。<br>（3）继续在剩下的元素中选择小的值，连接到第一个结点后面，并不断next将值小的结点连接到第一个结点后面，直到某一个链表为空。<br>（4）当两个链表长度不一致时，也就是比较完成后其中一个链表为空，此时需要把另外一个链表剩下的元素都连接到第一个结点的后面。</p></blockquote><h5 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoOrderedLists</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;</span><br><span class="line">    ListNode* pTail = <span class="literal">NULL</span>;<span class="comment">//指向新链表的最后一个结点 pTail-&gt;next去连接</span></span><br><span class="line">    ListNode* newHead = <span class="literal">NULL</span>;<span class="comment">//指向合并后链表第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead2)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//确定头指针</span></span><br><span class="line">        <span class="keyword">if</span> ( pHead1-&gt;data &lt; pHead2-&gt;data)&#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;<span class="comment">//指向链表的第二个结点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pTail = newHead;<span class="comment">//指向第一个结点</span></span><br><span class="line">        <span class="keyword">while</span> ( pHead1 &amp;&amp; pHead2) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( pHead1-&gt;data &lt;= pHead2-&gt;data )&#123;</span><br><span class="line">                pTail-&gt;next = pHead1;  </span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                pTail-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = pTail-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">            pTail-&gt;next = pHead2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead2)&#123;</span><br><span class="line">            pTail-&gt;next = pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归方案"><a href="#2-递归方案" class="headerlink" title="2 递归方案"></a>2 递归方案</h4><h5 id="2-1-解题思想"><a href="#2-1-解题思想" class="headerlink" title="2.1 解题思想"></a>2.1 解题思想</h5><blockquote><p>（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。<br>（2）比较两个链表第一个结点的大小，确定头结点的位置<br>（3）头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复（2 ）（3） 步，直到有链表为空。</p></blockquote><h5 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoOrderedLists</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;</span><br><span class="line">    ListNode* newHead = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead1)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span> ==pHead2)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;data &lt; pHead2-&gt;data)&#123;</span><br><span class="line">            newHead = pHead1;</span><br><span class="line">            newHead-&gt;next = mergeTwoOrderedLists(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead = pHead2;</span><br><span class="line">            newHead-&gt;next = mergeTwoOrderedLists(pHead1, pHead2-&gt;next);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/fz0rq.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。题目难度为 Easy，目前通过率为 45.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第 20 号问题：有效的括号</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC20%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第20号问题：有效的括号/</id>
    <published>2019-08-21T06:51:19.000Z</published>
    <updated>2019-08-21T05:55:31.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。</p><p>这里我们使用<strong>栈</strong>。</p><ul><li>遍历输入字符串</li><li>如果当前字符为左半边括号时，则将其压入栈中</li><li>如果遇到右半边括号时，<strong>分类讨论：</strong></li><li>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环  </li><li>2）若此时栈为空，则直接返回false</li><li>3）若不为对应的左半边括号，反之返回false</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181108111124.gif" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line"></span><br><span class="line">        stack&lt;char&gt; stack;</span><br><span class="line">        for( int i = 0 ; i &lt; s.size() ; i ++ )</span><br><span class="line">            if( s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;)</span><br><span class="line">                stack.push(s[i]);</span><br><span class="line">            else&#123;</span><br><span class="line"></span><br><span class="line">                if( stack.size() == 0 )</span><br><span class="line">                    return false;</span><br><span class="line"></span><br><span class="line">                char c = stack.top();</span><br><span class="line">                stack.pop();</span><br><span class="line"></span><br><span class="line">                char match;</span><br><span class="line">                if( s[i] == &apos;)&apos; )&#123;</span><br><span class="line">                    match = &apos;(&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if( s[i] == &apos;]&apos; )&#123;</span><br><span class="line">                    match = &apos;[&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    match = &apos;&#123;&apos;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(c != match)  return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if( stack.size() != 0 )</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/fz0rq.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;cod
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第 9 号问题：回文数</title>
    <link href="http://yoursite.com/2019/08/21/LeetCode%E7%AC%AC9%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/21/LeetCode第9号问题：回文数/</id>
    <published>2019-08-21T05:50:51.000Z</published>
    <updated>2019-08-21T05:55:25.214Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 第 9 号问题：回文数。题目难度为 Easy，目前通过率为 56.0%。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="解法一：普通解法"><a href="#解法一：普通解法" class="headerlink" title="解法一：普通解法"></a>解法一：普通解法</h3><p>最好理解的一种解法就是先将 <strong>整数转为字符串</strong> ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。</p><h4 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h4><p><img src="https://raw.githubusercontent.com/MisterBooo/myBlogPic/master/20190525181152.gif" alt></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///简单粗暴，看看就行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String reversedStr = (<span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>)).reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="string">""</span>).equals(reversedStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：进阶解法—数学解法"><a href="#解法二：进阶解法—数学解法" class="headerlink" title="解法二：进阶解法—数学解法"></a>解法二：进阶解法—数学解法</h3><p>通过取整和取余操作获取整数中对应的数字进行比较。</p><p>举个例子：1221 这个数字。</p><ul><li>通过计算 1221 / 1000， 得首位1</li><li>通过计算 1221 % 10， 可得末位 1</li><li>进行比较</li><li>再将 22 取出来继续比较</li></ul><h4 id="动画描述-1"><a href="#动画描述-1" class="headerlink" title="动画描述"></a>动画描述</h4><p><img src="https://raw.githubusercontent.com/MisterBooo/myBlogPic/master/20190525181202.gif" alt></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = x / div;</span><br><span class="line">            <span class="keyword">int</span> right = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            x = (x % div) / <span class="number">10</span>;</span><br><span class="line">            div /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法三：进阶解法—巧妙解法"><a href="#解法三：进阶解法—巧妙解法" class="headerlink" title="解法三：进阶解法—巧妙解法"></a>解法三：进阶解法—巧妙解法</h3><p>直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。</p><p>所以这个解法的操作就是 <strong>取出后半段数字进行翻转</strong>。</p><p>这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。</p><p>具体做法如下：</p><ul><li>每次进行取余操作 （ %10），取出最低的数字：<code>y = x % 10</code></li><li>将最低的数字加到取出数的末尾：<code>revertNum = revertNum * 10 + y</code></li><li>每取一个最低位数字，x 都要自除以 10</li><li>判断 <code>x</code> 是不是小于 <code>revertNum</code> ，当它小于的时候，说明数字已经对半或者过半了</li><li>最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。</li></ul><h4 id="动画描述-2"><a href="#动画描述-2" class="headerlink" title="动画描述"></a>动画描述</h4><p><img src="https://raw.githubusercontent.com/MisterBooo/myBlogPic/master/20190525181211.png" alt></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 第 9 号问题：回文数。题目难度为 Easy，目前通过率为 56.0%。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>浅析用枚举实现单例模式</title>
    <link href="http://yoursite.com/2019/08/21/%E6%B5%85%E6%9E%90%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/21/浅析用枚举实现单例模式/</id>
    <published>2019-08-21T05:22:30.000Z</published>
    <updated>2019-08-21T05:34:06.208Z</updated>
    
    <content type="html"><![CDATA[<p>1 引言<br>        相信如果能看到我这篇博客的小伙伴，肯定都看过Joshua Bloch大神说过的这句话：“单元素的枚举类型已经成为实现Singleton的最佳方法”。其实，第一次读到这句话，我连其中说的单元素指什么都不知道，尴尬。后来，网上看了搜索了好几篇文章，发现基本上都是转载自相同的一篇文章，而我的困惑是“为什么要用枚举类型实现单例模式呢”，文章中都说的很笼统，于是决定自己结合Joshua Bloch的《effective java》写一篇总结下，给后来的同学做个参考。</p><p>2 什么是单例模式<br>        关于什么是单例模式的定义，我之前的一篇文章（最简单的设计模式–单例模式）中有写过，主要是讲恶汉懒汉、线程安全方面得问题，我就不再重复了，只是做下单例模式的总结。之前文章中实现单例模式三个主要特点：1、构造方法私有化；2、实例化的变量引用私有化；3、获取实例的方法共有。</p><pre><code>如果不使用枚举，大家采用的一般都是“双重检查加锁”这种方式，如下，对单例模式还不了解的同学希望先大致看下这种思路，接下来的3.1和3.2都是针对这种实现方式进行探讨，了解过单例模式的同学可以跳过直接看3.1的内容：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 public class Singleton &#123;</span><br><span class="line"> 2     private volatile static Singleton uniqueInstance;</span><br><span class="line"> 3     private Singleton() &#123;&#125;</span><br><span class="line"> 4     public static Singleton getInstance() &#123;</span><br><span class="line"> 5         if (uniqueInstance == null) &#123;</span><br><span class="line"> 6             synchronized (Singleton.class)&#123;</span><br><span class="line"> 7                 if(uniqueInstance == null)&#123;//进入区域后，再检查一次，如果仍是null,才创建实例</span><br><span class="line"> 8                     uniqueInstance = new Singleton();</span><br><span class="line"> 9                 &#125;</span><br><span class="line">10             &#125;</span><br><span class="line">11         &#125;</span><br><span class="line">12         return uniqueInstance;</span><br><span class="line">13     &#125;</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>3 为什么要用枚举单例<br>3.1 私有化构造器并不保险<br>        《effective java》中只简单的提了几句话：“享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要低于这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。”下面我以代码来演示一下，大家就能明白：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1  public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line"> 2         Singleton s=Singleton.getInstance();</span><br><span class="line"> 3         Singleton sUsual=Singleton.getInstance();</span><br><span class="line"> 4         Constructor&lt;Singleton&gt; constructor=Singleton.class.getDeclaredConstructor();</span><br><span class="line"> 5         constructor.setAccessible(true);</span><br><span class="line"> 6         Singleton sReflection=constructor.newInstance();</span><br><span class="line"> 7         System.out.println(s+&quot;\n&quot;+sUsual+&quot;\n&quot;+sReflection);</span><br><span class="line"> 8         System.out.println(&quot;正常情况下，实例化两个实例是否相同：&quot;+(s==sUsual));</span><br><span class="line"> 9         System.out.println(&quot;通过反射攻击单例模式情况下，实例化两个实例是否相同：&quot;+(s==sReflection));</span><br><span class="line">10     &#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><p>com.lxp.pattern.singleton.Singleton@1540e19d<br>com.lxp.pattern.singleton.Singleton@1540e19d<br>com.lxp.pattern.singleton.Singleton@677327b6<br>正常情况下，实例化两个实例是否相同：true<br>通过反射攻击单例模式情况下，实例化两个实例是否相同：false<br>既然存在反射可以攻击的问题，就需要按照Joshua Bloch做说的，加个异常处理。这里我就不演示了，等会讲到枚举我再演示。</p><p>3.2 序列化问题<br>大家先看下面这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> 1 public class SerSingleton implements Serializable &#123;</span><br><span class="line"> 2     private volatile static SerSingleton uniqueInstance;</span><br><span class="line"> 3     private  String content;</span><br><span class="line"> 4     public String getContent() &#123;</span><br><span class="line"> 5         return content;</span><br><span class="line"> 6     &#125;</span><br><span class="line"> 7 </span><br><span class="line"> 8     public void setContent(String content) &#123;</span><br><span class="line"> 9         this.content = content;</span><br><span class="line">10     &#125;</span><br><span class="line">11     private SerSingleton() &#123;</span><br><span class="line">12     &#125;</span><br><span class="line">13 </span><br><span class="line">14     public static SerSingleton getInstance() &#123;</span><br><span class="line">15         if (uniqueInstance == null) &#123;</span><br><span class="line">16             synchronized (SerSingleton.class) &#123;</span><br><span class="line">17                 if (uniqueInstance == null) &#123;</span><br><span class="line">18                     uniqueInstance = new SerSingleton();</span><br><span class="line">19                 &#125;</span><br><span class="line">20             &#125;</span><br><span class="line">21         &#125;</span><br><span class="line">22         return uniqueInstance;</span><br><span class="line">23     &#125;</span><br><span class="line">24 </span><br><span class="line">25     </span><br><span class="line">26     public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">27         SerSingleton s = SerSingleton.getInstance();</span><br><span class="line">28         s.setContent(&quot;单例序列化&quot;);</span><br><span class="line">29         System.out.println(&quot;序列化前读取其中的内容：&quot;+s.getContent());</span><br><span class="line">30         ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerSingleton.obj&quot;));</span><br><span class="line">31         oos.writeObject(s);</span><br><span class="line">32         oos.flush();</span><br><span class="line">33         oos.close();</span><br><span class="line">34 </span><br><span class="line">35         FileInputStream fis = new FileInputStream(&quot;SerSingleton.obj&quot;);</span><br><span class="line">36         ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class="line">37         SerSingleton s1 = (SerSingleton)ois.readObject();</span><br><span class="line">38         ois.close();</span><br><span class="line">39         System.out.println(s+&quot;\n&quot;+s1);</span><br><span class="line">40         System.out.println(&quot;序列化后读取其中的内容：&quot;+s1.getContent());</span><br><span class="line">41         System.out.println(&quot;序列化前后两个是否同一个：&quot;+(s==s1));</span><br><span class="line">42     &#125;</span><br><span class="line">43     </span><br><span class="line">44 &#125;</span><br></pre></td></tr></table></figure><p>先猜猜看输出结果：</p><p>序列化前读取其中的内容：单例序列化<br>com.lxp.pattern.singleton.SerSingleton@135fbaa4<br>com.lxp.pattern.singleton.SerSingleton@58372a00<br>序列化后读取其中的内容：单例序列化<br>序列化前后两个是否同一个：false<br>        可以看出，序列化前后两个对象并不想等。为什么会出现这种问题呢？这个讲起来，又可以写一篇博客了，简单来说“任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。”当然，这个问题也是可以解决的，想详细了解的同学可以翻看《effective java》第77条：对于实例控制，枚举类型优于readResolve。</p><p>3.3 枚举类详解<br>3.3.1 枚举单例定义<br>咱们先来看一下枚举类型单例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，是不是觉得好简单，只有这么点代码，其实也没这么简单啦，编译后相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 public final class  EnumSingleton extends Enum&lt; EnumSingleton&gt; &#123;</span><br><span class="line">2         public static final  EnumSingleton  ENUMSINGLETON;</span><br><span class="line">3         public static  EnumSingleton[] values();</span><br><span class="line">4         public static  EnumSingleton valueOf(String s);</span><br><span class="line">5         static &#123;&#125;;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>由反编译后的代码可知，DATASOURCE 被声明为 static 的，根据在【单例深思】饿汉式与类加载 中所描述的类加载过程，可以知道虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确的加锁、同步。所以，枚举实现是在实例化时是线程安全。</clinit></p><p>接下来看看序列化问题：</p><p>Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。<br>在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。<br>也就是说，以下面枚举为例，序列化的时候只将 DATASOURCE 这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><p>public enum DataSourceEnum {<br>    DATASOURCE;<br>}  </p><p>由此可知，枚举天生保证序列化单例。</p><p>咱们先来验证下会不会避免上述的两个问题，先看下枚举单例的优点，然后再来讲原理。</p><p>3.3.2 避免反射攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 public enum  EnumSingleton &#123;</span><br><span class="line"> 2     INSTANCE;</span><br><span class="line"> 3     public EnumSingleton getInstance()&#123;</span><br><span class="line"> 4         return INSTANCE;</span><br><span class="line"> 5     &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7     public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line"> 8         EnumSingleton singleton1=EnumSingleton.INSTANCE;</span><br><span class="line"> 9         EnumSingleton singleton2=EnumSingleton.INSTANCE;</span><br><span class="line">10         System.out.println(&quot;正常情况下，实例化两个实例是否相同：&quot;+(singleton1==singleton2));</span><br><span class="line">11         Constructor&lt;EnumSingleton&gt; constructor= null;</span><br><span class="line">12         constructor = EnumSingleton.class.getDeclaredConstructor();</span><br><span class="line">13         constructor.setAccessible(true);</span><br><span class="line">14         EnumSingleton singleton3= null;</span><br><span class="line">15         singleton3 = constructor.newInstance();</span><br><span class="line">16         System.out.println(singleton1+&quot;\n&quot;+singleton2+&quot;\n&quot;+singleton3);</span><br><span class="line">17         System.out.println(&quot;通过反射攻击单例模式情况下，实例化两个实例是否相同：&quot;+(singleton1==singleton3));</span><br><span class="line">18     &#125;</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure><p>结果就报异常了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.lxp.pattern.singleton.EnumSingleton.&lt;init&gt;()</span><br><span class="line"> 2     at java.lang.Class.getConstructor0(Class.java:3082)</span><br><span class="line"> 3     at java.lang.Class.getDeclaredConstructor(Class.java:2178)</span><br><span class="line"> 4     at com.lxp.pattern.singleton.EnumSingleton.main(EnumSingleton.java:20)</span><br><span class="line"> 5     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line"> 6     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line"> 7     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line"> 8     at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line"> 9     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br><span class="line">10 正常情况下，实例化两个实例是否相同：true</span><br></pre></td></tr></table></figure><p>然后debug模式，可以发现是因为EnumSingleton.class.getDeclaredConstructors()获取所有构造器，会发现并没有我们所设置的无参构造器，只有一个参数为（String.class,int.class）构造器，然后看下Enum源码就明白，这两个参数是name和ordial两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line"> 2             implements Comparable&lt;E&gt;, Serializable &#123;</span><br><span class="line"> 3         private final String name;</span><br><span class="line"> 4         public final String name() &#123;</span><br><span class="line"> 5             return name;</span><br><span class="line"> 6         &#125;</span><br><span class="line"> 7         private final int ordinal;</span><br><span class="line"> 8         public final int ordinal() &#123;</span><br><span class="line"> 9             return ordinal;</span><br><span class="line">10         &#125;</span><br><span class="line">11         protected Enum(String name, int ordinal) &#123;</span><br><span class="line">12             this.name = name;</span><br><span class="line">13             this.ordinal = ordinal;</span><br><span class="line">14         &#125;</span><br><span class="line">15         //余下省略</span><br></pre></td></tr></table></figure><pre><code>枚举Enum是个抽象类，其实一旦一个类声明为枚举，实际上就是继承了Enum，所以会有（String.class,int.class）的构造器。既然是可以获取到父类Enum的构造器，那你也许会说刚才我的反射是因为自身的类没有无参构造方法才导致的异常，并不能说单例枚举避免了反射攻击。好的，那我们就使用父类Enum的构造器，看看是什么情况:</code></pre><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 public enum  EnumSingleton &#123;</span><br><span class="line"> 2     INSTANCE;</span><br><span class="line"> 3     public EnumSingleton getInstance()&#123;</span><br><span class="line"> 4         return INSTANCE;</span><br><span class="line"> 5     &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7     public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line"> 8         EnumSingleton singleton1=EnumSingleton.INSTANCE;</span><br><span class="line"> 9         EnumSingleton singleton2=EnumSingleton.INSTANCE;</span><br><span class="line">10         System.out.println(&quot;正常情况下，实例化两个实例是否相同：&quot;+(singleton1==singleton2));</span><br><span class="line">11         Constructor&lt;EnumSingleton&gt; constructor= null;</span><br><span class="line">12 //        constructor = EnumSingleton.class.getDeclaredConstructor();</span><br><span class="line">13         constructor = EnumSingleton.class.getDeclaredConstructor(String.class,int.class);//其父类的构造器</span><br><span class="line">14         constructor.setAccessible(true);</span><br><span class="line">15         EnumSingleton singleton3= null;</span><br><span class="line">16         //singleton3 = constructor.newInstance();</span><br><span class="line">17         singleton3 = constructor.newInstance(&quot;testInstance&quot;,66);</span><br><span class="line">18         System.out.println(singleton1+&quot;\n&quot;+singleton2+&quot;\n&quot;+singleton3);</span><br><span class="line">19         System.out.println(&quot;通过反射攻击单例模式情况下，实例化两个实例是否相同：&quot;+(singleton1==singleton3));</span><br><span class="line">20     &#125;</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure><p>然后咱们看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">正常情况下，实例化两个实例是否相同：true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br><span class="line">    at com.lxp.pattern.singleton.EnumSingleton.main(EnumSingleton.java:25)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br></pre></td></tr></table></figure><pre><code>继续报异常。之前是因为没有无参构造器，这次拿到了父类的构造器了，只是在执行第17行(我没有复制import等包，所以行号少于我自己运行的代码)时候抛出异常，说是不能够反射，我们看下Constructor类的newInstance方法源码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 @CallerSensitive</span><br><span class="line"> 2     public T newInstance(Object ... initargs)</span><br><span class="line"> 3         throws InstantiationException, IllegalAccessException,</span><br><span class="line"> 4                IllegalArgumentException, InvocationTargetException</span><br><span class="line"> 5     &#123;</span><br><span class="line"> 6         if (!override) &#123;</span><br><span class="line"> 7             if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line"> 8                 Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line"> 9                 checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">10             &#125;</span><br><span class="line">11         &#125;</span><br><span class="line">12         if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span><br><span class="line">13             throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">14         ConstructorAccessor ca = constructorAccessor;   // read volatile</span><br><span class="line">15         if (ca == null) &#123;</span><br><span class="line">16             ca = acquireConstructorAccessor();</span><br><span class="line">17         &#125;</span><br><span class="line">18         @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">19         T inst = (T) ca.newInstance(initargs);</span><br><span class="line">20         return inst;</span><br><span class="line">21     &#125;</span><br></pre></td></tr></table></figure><p>请看黄颜色标注的第12行源码，说明反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。</p><p>3.3.3 避免序列化问题<br> 我按照3.2中方式来写，作为对比，方面大家看的更清晰些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1 public enum  SerEnumSingleton implements Serializable &#123;</span><br><span class="line"> 2     INSTANCE;</span><br><span class="line"> 3     private  String content;</span><br><span class="line"> 4     public String getContent() &#123;</span><br><span class="line"> 5         return content;</span><br><span class="line"> 6     &#125;</span><br><span class="line"> 7     public void setContent(String content) &#123;</span><br><span class="line"> 8         this.content = content;</span><br><span class="line"> 9     &#125;</span><br><span class="line">10     private SerEnumSingleton() &#123;</span><br><span class="line">11     &#125;</span><br><span class="line">12 </span><br><span class="line">13     public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">14         SerEnumSingleton s = SerEnumSingleton.INSTANCE;</span><br><span class="line">15         s.setContent(&quot;枚举单例序列化&quot;);</span><br><span class="line">16         System.out.println(&quot;枚举序列化前读取其中的内容：&quot;+s.getContent());</span><br><span class="line">17         ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;SerEnumSingleton.obj&quot;));</span><br><span class="line">18         oos.writeObject(s);</span><br><span class="line">19         oos.flush();</span><br><span class="line">20         oos.close();</span><br><span class="line">21 </span><br><span class="line">22         FileInputStream fis = new FileInputStream(&quot;SerEnumSingleton.obj&quot;);</span><br><span class="line">23         ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class="line">24         SerEnumSingleton s1 = (SerEnumSingleton)ois.readObject();</span><br><span class="line">25         ois.close();</span><br><span class="line">26         System.out.println(s+&quot;\n&quot;+s1);</span><br><span class="line">27         System.out.println(&quot;枚举序列化后读取其中的内容：&quot;+s1.getContent());</span><br><span class="line">28         System.out.println(&quot;枚举序列化前后两个是否同一个：&quot;+(s==s1));</span><br><span class="line">29     &#125;</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p>1 枚举序列化前读取其中的内容：枚举单例序列化<br>2 INSTANCE<br>3 INSTANCE<br>4 枚举序列化后读取其中的内容：枚举单例序列化<br>5 枚举序列化前后两个是否同一个：true<br>        枚举类是JDK1.5才出现的，那之前的程序员面对反射攻击和序列化问题是怎么解决的呢？其实就是像Enum源码那样解决的，只是现在可以用enum可以使我们代码量变的极其简洁了。至此，相信同学们应该能明白了为什么Joshua Bloch说的“单元素的枚举类型已经成为实现Singleton的最佳方法”了吧，也算解决了我自己的困惑。既然能解决这些问题，还能使代码量变的极其简洁，那我们就有理由选枚举单例模式了。对了，解决序列化问题，要先懂transient和readObject，鉴于我的主要目的不在于此，就不在此写这两个原理了。</p><p>参考：<br>1、《Effective Java》（第2版）：p14-15，p271-274</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 引言&lt;br&gt;        相信如果能看到我这篇博客的小伙伴，肯定都看过Joshua Bloch大神说过的这句话：“单元素的枚举类型已经成为实现Singleton的最佳方法”。其实，第一次读到这句话，我连其中说的单元素指什么都不知道，尴尬。后来，网上看了搜索了好几篇文章
      
    
    </summary>
    
    
      <category term="浅析java" scheme="http://yoursite.com/tags/%E6%B5%85%E6%9E%90java/"/>
    
  </entry>
  
  <entry>
    <title>控制反转（IoC）和依赖注入（DI）的区别</title>
    <link href="http://yoursite.com/2019/08/18/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/18/控制反转（IoC）和依赖注入（DI）的区别/</id>
    <published>2019-08-18T01:22:42.000Z</published>
    <updated>2019-08-21T05:24:35.287Z</updated>
    
    <content type="html"><![CDATA[<p>IOC   inversion of control  控制反转</p><p>DI   Dependency Injection  依赖注入</p><p>要理解这两个概念，首先要搞清楚以下几个问题：</p><p>参与者都有谁？<br>依赖：谁依赖于谁？为什么需要依赖？<br>注入：谁注入于谁？到底注入什么？<br>控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了）？<br>依赖注入和控制反转是同一概念吗？<br>        下面就来简要的回答一下上述问题，把这些问题搞明白了，IoC/DI也就明白了。<br>（1）参与者都有谁：</p><pre><code>一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。又要名词解释一下，某个对象指的就是任意的、普通的Java对象; IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。</code></pre><p>（2）谁依赖于谁：</p><pre><code>当然是某个对象依赖于IoC/DI的容器</code></pre><p>（3）为什么需要依赖：</p><pre><code>对象需要IoC/DI的容器来提供对象需要的外部资源</code></pre><p>（4）谁注入于谁：</p><pre><code>很明显是IoC/DI的容器 注入 某个对象</code></pre><p>（5）到底注入什么：</p><pre><code>就是注入某个对象所需要的外部资源</code></pre><p>（6）谁控制谁：</p><pre><code>当然是IoC/DI的容器来控制对象了</code></pre><p>（7）控制什么：</p><pre><code>主要是控制对象实例的创建</code></pre><p>（8）为何叫反转：</p><pre><code>反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。</code></pre><p>用图例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如图7所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265411/6fe19539-32ce-3a62-bc20-f8dc1e819f82.gif" alt><br>                                      常规A使用C示意图</p><p>当有了IoC/DI的容器后，A类不再主动去创建C了，如图8所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265413/e29bb428-b9f0-3465-8601-671c3fa68b8c.gif" alt><br>                                      A类不再主动创建C</p><p>而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中，如图9所示：</p><p><img src="http://dl.iteye.com/upload/attachment/265415/2a537021-45c9-3fd3-80c5-18b9ace2b27a.gif" alt><br>                                      有IoC/DI容器后程序结构示意图</p><p>（9）依赖注入和控制反转是同一概念吗？</p><pre><code>根据上面的讲述，应该能看出来，依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</code></pre><p>（10）小结一下：</p><pre><code>其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。这么小小的一个改变其实是编程思想的一个大进步，这样就有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</code></pre><p>（11）接下演示一下依赖注入机制的过程</p><p>代码2<br>待注入的业务对象Content.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBusniess类展示了一个业务组件，它的实现需要对象Content的注入。代码3，代码4，代码5，6分别演示构造子注入（Constructor Injection），设值注入（Setter Injection）和接口注入（Interface Injection）三种方式。</p><p>代码3<br>构造子注入（Constructor Injection）MyBusiness.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码4<br>设值注入（Setter Injection） MyBusiness.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码5<br>   设置注入接口InContent.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>代码6接口注入（Interface Injection）MyBusiness.java</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness implements InContent&#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public void createContent(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusniess()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusniess()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IOC   inversion of control  控制反转&lt;/p&gt;
&lt;p&gt;DI   Dependency Injection  依赖注入&lt;/p&gt;
&lt;p&gt;要理解这两个概念，首先要搞清楚以下几个问题：&lt;/p&gt;
&lt;p&gt;参与者都有谁？&lt;br&gt;依赖：谁依赖于谁？为什么需要依赖？
      
    
    </summary>
    
    
      <category term="浅析java" scheme="http://yoursite.com/tags/%E6%B5%85%E6%9E%90java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第 3 号问题：无重复字符的最长子串</title>
    <link href="http://yoursite.com/2019/07/28/LeetCode%E7%AC%AC3%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/07/28/LeetCode第3号问题：无重复字符的最长子串/</id>
    <published>2019-07-28T07:57:48.000Z</published>
    <updated>2019-08-21T05:55:38.860Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>建立一个256位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/blog/o2acw.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><figcaption><span>1,暴力法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="comment">// 时间复杂度: O(len(s))</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(len(charset))</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> longgest =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt;=s.length() ; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isUnique(s,i,j))&#123;</span><br><span class="line">                        longgest = Math.max(longgest, j-i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> longgest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end ; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 2 号问题：两数相加</title>
    <link href="http://yoursite.com/2019/07/28/LeetCode%E7%AC%AC2%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/07/28/LeetCode第2号问题：两数相加/</id>
    <published>2019-07-28T04:32:41.000Z</published>
    <updated>2019-08-21T05:36:27.472Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 2 号问题：两数相加。题目难度为 Medium，目前通过率为 33.9% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181117122234.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/// 时间复杂度: O(n)</span><br><span class="line">/// 空间复杂度: O(n)</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode *dummyHead = new ListNode(-1);</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        int carried = 0;</span><br><span class="line">        while(p1 || p2 )&#123;</span><br><span class="line">            int a = p1 ? p1-&gt;val : 0;</span><br><span class="line">            int b = p2 ? p2-&gt;val : 0;</span><br><span class="line">            cur-&gt;next = new ListNode((a + b + carried) % 10);</span><br><span class="line">            carried = (a + b + carried) / 10;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            p1 = p1 ? p1-&gt;next : NULL;</span><br><span class="line">            p2 = p2 ? p2-&gt;next : NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur-&gt;next = carried ? new ListNode(1) : NULL;</span><br><span class="line">        ListNode* ret = dummyHead-&gt;next;</span><br><span class="line">        delete dummyHead;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 2 号问题：两数相加。题目难度为 Medium，目前通过率为 33.9% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第 1 号问题：两数之和</title>
    <link href="http://yoursite.com/2019/07/27/LeetCode%E7%AC%AC1%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/07/27/LeetCode第1号问题：两数之和/</id>
    <published>2019-07-27T07:57:48.000Z</published>
    <updated>2019-08-21T05:23:01.431Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用查找表来解决该问题。</p><p>设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums。</p><ul><li>每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值</li><li>在此次遍历中查找 record ，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值 i</li><li>如果未找到，则在 record 保存该元素与索引值 i</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181028221055.gif" alt="动画描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. Two Sum</span><br><span class="line">// https://leetcode.com/problems/two-sum/description/</span><br><span class="line">// 时间复杂度：O(n)</span><br><span class="line">// 空间复杂度：O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; record;</span><br><span class="line">        for(int i = 0 ; i &lt; nums.size() ; i ++)&#123;</span><br><span class="line">       </span><br><span class="line">            int complement = target - nums[i];</span><br><span class="line">            if(record.find(complement) != record.end())&#123;</span><br><span class="line">                int res[] = &#123;i, record[complement]&#125;;</span><br><span class="line">                return vector&lt;int&gt;(res, res + 2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
